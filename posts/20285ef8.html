<!DOCTYPE HTML>
<html lang="zh-CN">


<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="utf-8">
    <meta name="keywords" content="TCP/IP协议森林, Escape Escpae&#39;s Python Linux Bug Linnux运维之路 Python成长笔记 Web进击之旅 Bug解决之道 文所未闻 音乐墙 关于我">
    <meta name="description" content="听摇滚,但不偏颇;也挺古典,但不安逸">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <meta name="renderer" content="webkit|ie-stand|ie-comp">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="format-detection" content="telephone=no">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <!-- Global site tag (gtag.js) - Google Analytics -->


    <title>TCP/IP协议森林 | Escape</title>
    <link rel="icon" type="image/png" href="/favicon.png">

    <link rel="stylesheet" type="text/css" href="/libs/awesome/css/all.css">
    <link rel="stylesheet" type="text/css" href="/libs/materialize/materialize.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/aos/aos.css">
    <link rel="stylesheet" type="text/css" href="/libs/animate/animate.min.css">
    <link rel="stylesheet" type="text/css" href="/libs/lightGallery/css/lightgallery.min.css">
    <link rel="stylesheet" type="text/css" href="/css/matery.css">
    <link rel="stylesheet" type="text/css" href="/css/my.css">

    <script src="/libs/jquery/jquery.min.js"></script>

<link rel="stylesheet" href="/css/prism-tomorrow.css" type="text/css">
<link rel="stylesheet" href="/css/prism-line-numbers.css" type="text/css"></head>




<body>
    <header class="navbar-fixed">
    <nav id="headNav" class="bg-color nav-transparent">
        <div id="navContainer" class="nav-wrapper container">
            <div class="brand-logo">
                <a href="/" class="waves-effect waves-light">
                    
                    <img src="/medias/logo.png" class="logo-img" alt="LOGO">
                    
                    <span class="logo-span">Escape</span>
                </a>
            </div>
            

<a href="#" data-target="mobile-nav" class="sidenav-trigger button-collapse"><i class="fas fa-bars"></i></a>
<ul class="right nav-menu">
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/" class="waves-effect waves-light">
      
      <i class="fas fa-home" style="zoom: 0.6;"></i>
      
      <span>首页</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/tags" class="waves-effect waves-light">
      
      <i class="fas fa-tags" style="zoom: 0.6;"></i>
      
      <span>标签</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/categories" class="waves-effect waves-light">
      
      <i class="fas fa-bookmark" style="zoom: 0.6;"></i>
      
      <span>分类</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/archives" class="waves-effect waves-light">
      
      <i class="fas fa-archive" style="zoom: 0.6;"></i>
      
      <span>归档</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/about" class="waves-effect waves-light">
      
      <i class="fas fa-user-circle" style="zoom: 0.6;"></i>
      
      <span>关于</span>
    </a>
    
  </li>
  
  <li class="hide-on-med-and-down nav-item">
    
    <a href="/friends" class="waves-effect waves-light">
      
      <i class="fas fa-address-book" style="zoom: 0.6;"></i>
      
      <span>友情链接</span>
    </a>
    
  </li>
  
  <li>
    <a href="#searchModal" class="modal-trigger waves-effect waves-light">
      <i id="searchIcon" class="fas fa-search" title="搜索" style="zoom: 0.85;"></i>
    </a>
  </li>
</ul>


<div id="mobile-nav" class="side-nav sidenav">

    <div class="mobile-head bg-color">
        
        <img src="/medias/logo.png" class="logo-img circle responsive-img">
        
        <div class="logo-name">Escape</div>
        <div class="logo-desc">
            
            听摇滚,但不偏颇;也挺古典,但不安逸
            
        </div>
    </div>

    

    <ul class="menu-list mobile-menu-list">
        
        <li class="m-nav-item">
	  
		<a href="/" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-home"></i>
			
			首页
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/tags" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-tags"></i>
			
			标签
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/categories" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-bookmark"></i>
			
			分类
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/archives" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-archive"></i>
			
			归档
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/about" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-user-circle"></i>
			
			关于
		</a>
          
        </li>
        
        <li class="m-nav-item">
	  
		<a href="/friends" class="waves-effect waves-light">
			
			    <i class="fa-fw fas fa-address-book"></i>
			
			友情链接
		</a>
          
        </li>
        
        
        <li><div class="divider"></div></li>
        <li>
            <a href="https://github.com/EscapeLife" class="waves-effect waves-light" target="_blank">
                <i class="fab fa-github-square fa-fw"></i>Fork Me
            </a>
        </li>
        
    </ul>
</div>


        </div>

        
            <style>
    .nav-transparent .github-corner {
        display: none !important;
    }

    .github-corner {
        position: absolute;
        z-index: 10;
        top: 0;
        right: 0;
        border: 0;
        transform: scale(1.1);
    }

    .github-corner svg {
        color: #0f9d58;
        fill: #fff;
        height: 64px;
        width: 64px;
    }

    .github-corner:hover .octo-arm {
        animation: a 0.56s ease-in-out;
    }

    .github-corner .octo-arm {
        animation: none;
    }

    @keyframes a {
        0%,
        to {
            transform: rotate(0);
        }
        20%,
        60% {
            transform: rotate(-25deg);
        }
        40%,
        80% {
            transform: rotate(10deg);
        }
    }
</style>

<a href="https://github.com/EscapeLife" class="github-corner tooltipped hide-on-med-and-down" target="_blank"
   data-tooltip="Fork Me" data-position="left" data-delay="50">
    <svg viewBox="0 0 250 250" aria-hidden="true">
        <path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path>
        <path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2"
              fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm"></path>
        <path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z"
              fill="currentColor" class="octo-body"></path>
    </svg>
</a>
        
    </nav>

</header>

    
<script src="/libs/cryptojs/crypto-js.min.js"></script>
<script>
    (function() {
        let pwd = '';
        if (pwd && pwd.length > 0) {
            if (pwd !== CryptoJS.SHA256(prompt('请输入访问本文章的密码')).toString(CryptoJS.enc.Hex)) {
                alert('密码错误，将返回主页！');
                location.href = '/';
            }
        }
    })();
</script>




<div class="bg-cover pd-header post-cover" style="background-image: url('/images/learn-tcp-ip-protocol.jpg')">
    <div class="container" style="right: 0px;left: 0px;">
        <div class="row">
            <div class="col s12 m12 l12">
                <div class="brand">
                    <h1 class="description center-align post-title">TCP/IP协议森林</h1>
                </div>
            </div>
        </div>
    </div>
</div>




<main class="post-container content">

    
    <link rel="stylesheet" href="/libs/tocbot/tocbot.css">
<style>
    #articleContent h1::before,
    #articleContent h2::before,
    #articleContent h3::before,
    #articleContent h4::before,
    #articleContent h5::before,
    #articleContent h6::before {
        display: block;
        content: " ";
        height: 100px;
        margin-top: -100px;
        visibility: hidden;
    }

    #articleContent :focus {
        outline: none;
    }

    .toc-fixed {
        position: fixed;
        top: 64px;
    }

    .toc-widget {
        width: 345px;
        padding-left: 20px;
    }

    .toc-widget .toc-title {
        margin: 35px 0 15px 0;
        padding-left: 17px;
        font-size: 1.5rem;
        font-weight: bold;
        line-height: 1.5rem;
    }

    .toc-widget ol {
        padding: 0;
        list-style: none;
    }

    #toc-content {
        height: calc(100vh - 250px);
        overflow: auto;
    }

    #toc-content ol {
        padding-left: 10px;
    }

    #toc-content ol li {
        padding-left: 10px;
    }

    #toc-content .toc-link:hover {
        color: #42b983;
        font-weight: 700;
        text-decoration: underline;
    }

    #toc-content .toc-link::before {
        background-color: transparent;
        max-height: 25px;

        position: absolute;
        right: 23.5vw;
        display: block;
    }

    #toc-content .is-active-link {
        color: #42b983;
    }

    #floating-toc-btn {
        position: fixed;
        right: 15px;
        bottom: 76px;
        padding-top: 15px;
        margin-bottom: 0;
        z-index: 998;
    }

    #floating-toc-btn .btn-floating {
        width: 48px;
        height: 48px;
    }

    #floating-toc-btn .btn-floating i {
        line-height: 48px;
        font-size: 1.4rem;
    }
</style>
<div class="row">
    <div id="main-content" class="col s12 m12 l9">
        <!-- 文章内容详情 -->
<div id="artDetail">
    <div class="card">
        <div class="card-content article-info">
            <div class="row tag-cate">
                <div class="col s7">
                    
                    <div class="article-tag">
                        
                            <a href="/tags/Algorithm/">
                                <span class="chip bg-color">Algorithm</span>
                            </a>
                        
                    </div>
                    
                </div>
                <div class="col s5 right-align">
                    
                    <div class="post-cate">
                        <i class="fas fa-bookmark fa-fw icon-category"></i>
                        
                            <a href="/categories/Algo算法之美/" class="post-category">
                                Algo算法之美
                            </a>
                        
                    </div>
                    
                </div>
            </div>

            <div class="post-info">
                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-minus fa-fw"></i>发布日期:&nbsp;&nbsp;
                    2020-07-23
                </div>
                

                
                <div class="post-date info-break-policy">
                    <i class="far fa-calendar-check fa-fw"></i>更新日期:&nbsp;&nbsp;
                    2020-08-08
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-file-word fa-fw"></i>文章字数:&nbsp;&nbsp;
                    32.9k
                </div>
                

                
                <div class="info-break-policy">
                    <i class="far fa-clock fa-fw"></i>阅读时长:&nbsp;&nbsp;
                    118 分
                </div>
                

                
                    <div id="busuanzi_container_page_pv" class="info-break-policy">
                        <i class="far fa-eye fa-fw"></i>阅读次数:&nbsp;&nbsp;
                        <span id="busuanzi_value_page_pv"></span>
                    </div>
				
            </div>
        </div>
        <hr class="clearfix">
        <div class="card-content article-card-content">
            <div id="articleContent">
                <blockquote>
<p><strong>本文主要纪念 Vamei 博主，愿天堂也可以科学养猪！</strong></p>
</blockquote>
<p>互联网的目的是为了实现通信，而通信的基础是有一套行之有效的网络协议。正如我们在交谈的时候需要符合一定的语法和用语规范一样，机器之间的通话也必须符合协议。否则，每一台机器自言自语，永远也无法相互理解。<strong>“协议森林”</strong> 是一系列关于网络协议的文章。希望通过这些文章，能对错综复杂的协议森林进行一个简单的总结。</p>
<p>网络协议是技术，但又关乎设计与历史。<code>Ethernet</code>, <code>IP</code>, <code>UDP</code>, <code>TCP</code>, <code>HTTP</code>, <code>DNS</code>… 这些协议像是一片茂密的树林，盘根错节。协议之间相互关联。协议与协议有时合作，有时竞争，有时是弱肉强食的替代。网络协议的发展总是伴随着很有趣的历史故事，网络协议的产生都有其历史环境。一些网络协议可能看起来很笨拙，但放在当时，是聪明的解决方案。所以，在了解网络协议的时候，需要了解该协议的诞生过程和设计目的。</p>
<p>了解网络分层，是理解这个森林的第一步。而森林的心脏，是存在了三十多年的 <code>TCP/IP</code> 套装协议。在变化迅捷的 <code>IT</code> 领域，<code>TCP/IP</code> 坚如磐石的地位可以算是一个奇迹。这一点也是可以理解的。许多单机技术可以很快更新，比如 <code>Java</code> 和 <code>C++</code> 兴起，而 <code>Pascal</code> 语言、<code>Fortran</code> 语言快速没落。然而，网络协议的更换并不简单，这要求整个网络的所有设备的配合。网络协议是不老传说，它的相关技术，就非常值得拥有。</p>
<p>网络协议可以参考许多经典书籍。<strong>“协议森林”</strong> 忽略了许多细节，并采用比较直白的表达方式。</p>
<p><img src="/images/learn-tcp-ip-protocol.jpg" alt="TCP-IP协议森林"></p>
<hr>
<h2 id="1-综述"><a href="#1-综述" class="headerlink" title="1. 综述"></a>1. 综述</h2><h3 id="1-1-邮差与邮局-网络协议概观"><a href="#1-1-邮差与邮局-网络协议概观" class="headerlink" title="1.1 邮差与邮局 (网络协议概观)"></a>1.1 邮差与邮局 (网络协议概观)</h3><p>信号的传输总要符合一定的协议 <code>(protocol)</code>。比如说长城上放狼烟，看到狼烟的军队开始警备。这是因为人们已经预先约定好，狼烟这个物理信号代表了“敌人入侵”。这样一个 <strong>“狼烟=敌人入侵”</strong> 就是一个简单的协议。协议可以更复杂，比如摩尔斯码 <code>(Morse Code)</code>，使用短信号和长信号的组合，来代表不同的英文字母。比如 <code>SOS</code>(+++—+++, +代表短信号，-代表长信号)。这样 <strong>“+++ 相当于 S, — 相当于 O”</strong> 就是摩尔斯码规定的协议。然而更进一层，人们会知道 <code>SOS</code> 是求助信息，原因是我们有 <strong>“SOS=求救”</strong> 这个协议存在在脑海里。所以 <strong>“+++—+++=SOS=求救”</strong> 是一个由两个协议组成的分层通信系统。</p>
<p><img src="/images/learn-tcp-ip-protocol-1.jpg" alt="使用Morse Code的电报机"></p>
<p>和人与人之间的通信类似，计算机之间的通信也要遵循协议。</p>
<ul>
<li><strong>[1] 物理层(physical layer)</strong></li>
</ul>
<p>所谓的物理层，是指光纤、电缆或者电磁波等真实存在的物理媒介。这些媒介可以传送物理信号，比如亮度、电压或者振幅。对于数字应用来说，我们只需要两种物理信号来分别表示 <code>0</code> 和 <code>1</code>，比如用高电压表示 <code>1</code>，低电压表示 <code>0</code>，就构成了简单的物理层协议。针对某种媒介，电脑可以有相应的接口，用来接收物理信号，并解读成为 <code>0/1</code> 序列。</p>
<ul>
<li><strong>[2] 连接层(link layer)</strong></li>
</ul>
<p>在连接层<code>(link layer)</code>，信息以<code>帧(frame)</code>为单位传输。信息是一段有序的 <code>0/1</code> 序列，而帧，是这个序列中符合特定格式的一小段。连接层协议的功能就是识别 0/1 序列中所包含的帧。在帧中，有收信地址<code>(Source, SRC)</code>和送信地址<code>(Destination, DST)</code>，还有能够探测错误的校验序列(<code>Frame Check Sequence</code>)。当然，帧中最重要的最重要是所要传输的<code>数据(payload)</code>。这些数据往往符合更高层协议，供网络的上层使用。与数据相配套，帧中也有数据的类型(<code>Type</code>)信息。连接层协议不关心数据中到底包含什么。帧就像是一个信封，把数据包裹起来。</p>
<p>以太网<code>(Ethernet)</code>和 <code>WiFi</code> 是现在最常见的连接层协议。通过连接层协议，我们可以建立局域的以太网或者 <code>WiFi</code> 局域网，并让同一局域网中的两台计算机通信。连接层就像是一个社区的邮差，他认识社区中的每一户人。社区中的每个人都可以将一封信(帧)交给他，让他送给同一社区的另一户人家。</p>
<p><img src="/images/learn-tcp-ip-protocol-2.jpg" alt="连接层：社区小邮差"></p>
<ul>
<li><strong>[3] 网络层(network layer)</strong></li>
</ul>
<p>连接层让社区内部可以通信，但不同的社区之间该如何通信呢？比如说，让 <code>WiFi</code> 上网络上的一台计算机和以太网上的另一台计算机通信。我们需要一个 <strong>“中间人”</strong>。这个 <strong>“中间人”</strong> 必须有以下功能:</p>
<ol>
<li>能从物理层上在两个网络的接收和发送 <code>0/1</code> 序列</li>
<li>能同时理解两种网络的帧格式</li>
</ol>
<p>路由器<code>(router)</code>就是为此而产生的 <strong>“中间人”</strong>。一个路由器有多个网卡(<code>NIC</code>)。每个网卡可以接入到一个网络，并理解相应的连接层协议。在帧经过路由到达另一个网络的时候，路由会读取帧的信息，并改写以发送到另一个网络。所以路由器就像是在两个社区都有分支的邮局。一个社区的邮差将信送到本社区的邮局分支，而邮局会通过自己在另一个地区的分支将信转交给另一个社区的邮差手中，并由另一个社区的邮差最终送到目的地。</p>
<p><img src="/images/learn-tcp-ip-protocol-3.jpg" alt="通过路由连接的WiFi和以太网"></p>
<p>整个通信过程如下:</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">></span> WiFi上的计算机1 -<span class="token operator">></span> 路由WiFi接口 -<span class="token operator">></span> 路由以太网接口 -<span class="token operator">></span> 以太网上的计算机2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>在连接层，一个帧中只能记录起点 <code>SRC</code> 和终点 <code>DST</code> 两个地址。而上面的过程需要经过四个地址(计算机 1，WiFi 接口，以太网接口，计算机 2)。显然，仅仅靠连接层协议无法满足我们的需要。由于连接层协议开发在先，我们无法改动连接层协议，只能在连接层的数据<code>(payload)</code>，也就是信纸内部下功夫了。由此，<code>IP</code> 协议应运而生。</p>
<p>计算机 1，路由器和计算机 2 都要懂得 <code>IP</code> 协议。当计算机 1 写信的时候，会在信纸的开头写上这封信的出发地址和最终到达地址(注意，这里是信纸，而不是在信封上)，信封上写要送往的邮局。<code>WiFi</code> 网的邮差将信送往邮局。在邮局，信被打开，邮局工作人员看到最终地址，于是将信包装在一个新的信封中，写上出发地为邮局，到达地为计算机 2，并交给以太网的邮差，由以太网的邮差送往计算机 2。</p>
<p>(<code>IP</code> 协议还要求写如诸如校验等信息，交通状况等信息，以保护通信的稳定性。)</p>
<p><img src="/images/learn-tcp-ip-protocol-4.gif" alt="转交给邮局"></p>
<p>在连接层，邮差只负责在本社区送信，所以信封上的地址总是“第一条街第三座房子”，或者说“中心十字路口拐角的小房子”这样一些本地人才了解的地址描述，这给邮局的工作带来不便。所以邮局要求，信纸上写的地址必须是一个符合官方规定的“邮编”，也就是 <code>IP</code> 地址。这个地址为世界上的每一个房子编号(邮编)。当信件送到邮局的时候，邮局根据邮编，就能查到对应的地址描述，从而能顺利改写信封上的信息。</p>
<p>每个邮局一般连接多个社区，而一个社区也可以有多个邮局，分别通往不同的社区。有时候一封信要通过多个邮局转交，才能最终到达目的地，这个过程叫做路由<code>(routing)</code>。邮局将分离的局域网络连接成了互联，并最终构成了覆盖全球的互联网。</p>
<ul>
<li><strong>[4] 传输层(transport layer)</strong></li>
</ul>
<p>上面的三层协议让不同的计算机之间可以通信。但计算机中可能运行了许多个进程，每个进程都可能有自己的通信需求。比如我们打开 <code>firefox</code> 浏览网页，与此同时，又用 <code>outlook</code> 来接收邮件。一个计算机里的多个进程就像是住在一所房子里住的好几个人，</p>
<p>我们之前的通信协议，足以让我们把信息从一所房子发送到另一所方法。但如何将信精确的送到某个人手里呢？遵照之前相同的逻辑，我们需要在信上增加新的信息，比如收信人的姓名，才可能让信送到。所以，传输层就是在信纸的空白上写上新的“收信人”信息。每一所房子会配备一个管理员(传输层协议)。管理员从邮差手中接过信，会根据“收信人”，将信送给房子中的某个人。</p>
<p><img src="/images/learn-tcp-ip-protocol-5.jpg" alt="管理员"></p>
<p>传输层协议，比如 <code>TCP</code> 和 <code>UDP</code>，使用端口号(<code>port number</code>)来识别收信人(某个进程)。在写信的时候，我们写上目的地的端口。当信到达目的地的管理员手中，他会根据传输层协议，识别端口号，将信送给不同的人。</p>
<p><code>TCP</code> 和 <code>UDP</code> 协议是两种不同的传输层协议。<code>UDP</code> 协议类似于我们的信件交流过程。<code>TCP</code> 协议则好像两个情人间的频繁通信。一个小情人要表达的感情太多，以致于连续写了好几封信。而另一方必须将这些信按顺序排列起来，才能看明白全部的意思。<code>TCP</code> 协议还有控制网络交通等功能。</p>
<ul>
<li><strong>[5] 应用层(application layer)</strong></li>
</ul>
<p>通过上面的几层协议，我们已经可以在任意两个人(进程)之间进行通信。但人们显然还不满足。每个人从事的是不同的行业。有的人是律师，有的人外交官。律师之间的通信，要严格的律师术语，以免产生纠纷。外交官之间的通信，必须符合一定的外交格式，以免发生外交误会。再比如间谍通过暗号来传递加密信息。应用层协议是对信件内容进一步的用语规范。应用层的协议包括用于 <code>Web</code> 浏览的 <code>HTTP</code> 协议，用于传输文件的 <code>FTP</code> 协议，用于 <code>Email</code> 的 <code>IMAP</code> 等等。</p>
<p><img src="/images/learn-tcp-ip-protocol-6.jpg" alt="外交通信"></p>
<ul>
<li><strong>[6] 总结陈述</strong></li>
</ul>
<p>总过网络分层，我们从原始的 <code>0/1</code> 序列抽象出</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token operator">></span> 本地地址<span class="token punctuation">(</span>邮差<span class="token punctuation">)</span>、邮编<span class="token punctuation">(</span>邮局<span class="token punctuation">)</span>、收信人<span class="token punctuation">(</span>管理员<span class="token punctuation">)</span>、收信人行业<span class="token punctuation">(</span>用语规范<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这些概念。这些概念最终允许互联网上的分布于两台计算机的两个进程相互通信。写信人必须按照各层的协议，封装(<code>encapsulation</code>)好整个信封；而收信人则按照相反的顺序，来拆开这个信封。整个过程是 <strong>可读信息 -&gt; 二进制 -&gt; 可读信息</strong>。</p>
<p>计算机只能理解和传输 <code>0/1</code> 序列，而计算机的用户则总是输入和输出可读信息。网络协议保证了可读信息在整个转换和传输过程中的完整性。计算机协议本身还有更多的细节需要深入。这篇文章只是从分层的角度描述各个层次所实现的功能。</p>
<hr>
<h2 id="2-连接层协议"><a href="#2-连接层协议" class="headerlink" title="2. 连接层协议"></a>2. 连接层协议</h2><h3 id="2-1-小喇叭开始广播-以太网与-WiFi-协议"><a href="#2-1-小喇叭开始广播-以太网与-WiFi-协议" class="headerlink" title="2.1 小喇叭开始广播 (以太网与 WiFi 协议)"></a>2.1 小喇叭开始广播 (以太网与 WiFi 协议)</h3><p>“小喇叭开始广播啦”，如果你知道这个，你一定是老一辈的人。“小喇叭”是五十年代到八十年代的儿童广播节目。在节目一开始，都会有一段这样的播音：“小朋友，小喇叭开始广播了！”。听到这里，收音机前的小朋友就兴奋起来，准备好听节目了：这一期的内容是以太网(<code>Ethernet</code>)协议与 <code>WiFi</code>。</p>
<p>我们在邮差与邮局中说到，以太网和 <code>WiFi</code> 是连接层的两种协议。在连接层，信息的传输单位称为帧(<code>frame</code>)。数据(<code>payload</code>)是包裹在帧中的一部分，帧上注明收信地址和送信地址。连接层实现了“本地社区”的通信。</p>
<ul>
<li><strong>[1] 以太网的帧格式</strong></li>
</ul>
<p>帧本身是一段有限的 <code>0/1</code> 序列。它可以分为头部、数据(<code>Payload</code>)和尾部三部分组成，帧按照下面的顺序从头到尾依次被发送/接收。我们下面进一步解释各个区域。</p>
<table>
<thead>
<tr>
<th>1</th>
<th>2</th>
<th>3</th>
<th>4</th>
<th>5</th>
<th>6</th>
<th>7</th>
<th>8</th>
<th>9</th>
</tr>
</thead>
<tbody><tr>
<td>Preamble</td>
<td>SFD</td>
<td>DST</td>
<td>SRC</td>
<td>Type</td>
<td>Payload(Data)</td>
<td>Pad</td>
<td>FCS</td>
<td>Extension</td>
</tr>
</tbody></table>
<ul>
<li><strong>[1.1] 头部</strong></li>
</ul>
<p>帧的最初 <code>7</code> 个字节被称为序言(<code>preamble</code>)。它的每个字节都是 <code>0xAA</code>(这里是十六进制，也就是二进制的<code>10101010</code>)。通常，我们都会预定好以一定的频率发送 <code>0/1</code> 序列(比如每秒<code>10bit</code>)。如果接收设备以其他频率接收(比如每秒<code>5bit</code>)，那么就会错漏掉应该接收的 <code>0/1</code> 信息。但是，由于网卡的不同，发送方和接收方即使预订的频率相同，两者也可能由于物理原因发生偏差。这就好像两个人约好的 <code>10</code> 点见，结果一个人表快，一个人表慢一样。序言是为了让接收设备调整接收频率，以便与发送设备的频率一致，这个过程就叫做<strong>时钟复原</strong>(<code>recover the clock</code>)。</p>
<p>就像在收听广播之前，调整转钮，直到声音清晰。网卡会在接收序言的过程中不断微调自己的接收频率，直到自己 <strong>“听到”</strong> 是 <code>...1010...</code>。时钟调整好之后，我们等待帧的起始信号(<code>SFD, start frame delimiter</code>)。<code>SFD</code> 是固定的值 <code>0xAB</code>。这个 <code>0xAB</code> 就好像“小喇叭开始广播啦”一样，提醒我们好节目就要上演了。</p>
<p><img src="/images/learn-tcp-ip-protocol-10.jpg" alt="Preamble和SFD"></p>
<p>紧随 <code>SFD</code> 之后的是 <code>6</code> 字节的目的地(<code>DST</code>, <code>destination</code>)和 <code>6</code> 字节的发出地(<code>SRC</code>, <code>source</code>)。这就是我们在邮差和邮局中的介绍一样，为信封写上目的地和发出地。要注意，这里写在信封上的是对地址的<strong>“本地描述”</strong>，也就是 <code>MAC</code> 地址。<code>MAC</code> 地址是物理设备自带的序号，只能在同一个以太网中被识别。也就是说，邮差只熟悉自己的社区。</p>
<p>头部的最后一个区域是 <code>Type</code>，用以说明数据部分的类型。比如 <code>0x0800</code> 为 <code>IPv4</code>，而 <code>0x0806</code> 为 <code>ARP</code>。</p>
<ul>
<li><strong>[1.2] 数据</strong></li>
</ul>
<p>数据一般包含有符合更高层协议的数据，比如 <code>IP</code> 包。连接层协议本身并不在乎数据是什么，它只负责传输。注意，数据尾部可能填充有一串 <code>0</code>(PAD 区域)。填充 <code>0</code> 的原因是，一个帧需要超过一定的最小长度。</p>
<ul>
<li><strong>[1.3] 尾部</strong></li>
</ul>
<p>跟随在数据之后的是<strong>校验序列</strong>(<code>FCS</code>)。校验序列是为了检验数据的传输是否发生错误。在物理层，我们通过一些物理信号来表示 <code>0/1</code> 序列(比如高压/低压，高频率/低频率等)，但这些物理信号可能在传输过程中受到影响，以致于发生错误。如何来发现我们的数据是正确的呢？</p>
<p>一个方法是将数据发送两遍，然后对比一下是否一样。但这样就大大降低了网络的效率。<code>FCS</code> 采用了循环冗余校验(<code>CRC</code>)算法。这就好像是一家饭店的老板雇佣了一个收银员，但他又担心收银员黑钱。可是每天营业额很大，老板即使坐在旁边看，也不能用记住收到的总数。所以他采取了一个聪明的办法：只记住收到钱的最后一位(比如收到 <code>19</code> 元，老板记住 <code>9</code>)。当有新的进账(比如 <code>13</code>，尾数为 <code>3</code>)，他就将新的尾数和旧的尾数相加，再记住和的尾数(也就是 <code>2</code>)。当收银员交给老板钱的时候，老板只用看总额的最后一位是否和自己记的最后一位相同，就可以知道收银员是否诚实了。如果说我们的数据是收银的总额的话，我们的 <code>FCS</code> 就是老板记录的尾数。如果两者不相符，我们就知道数据在传输的过程中出现错误，不能使用。</p>
<p><img src="/images/learn-tcp-ip-protocol-11.jpg" alt="有FCS在盯着"></p>
<p>上面的比喻实际上是用营业总额不断的除以 <code>10</code>，获得最终的尾数。<code>CRC</code> 算法也相类似。<code>n</code> 位 <code>CRC</code> 算法取一个 <code>n bit</code> 的因子，比如下面的 <code>1011</code>。数据序列结尾增加 <code>n-1</code> 个 <code>0</code>。因子与数据序列的不断进行 <code>XOR</code> 运算，直到得到 <code>n-1</code> 位的余数，也就是 <code>100</code>。该余数各位取反(<code>011</code>)，然后存储在 <code>FCS</code> 的位置。</p>
<p>下面例子用的是 <code>4</code> 位 <code>CRC</code>。在 <code>Ethernet</code> 中使用的因子为 <code>32</code> 位的，以达到更好的检测效果。</p>
<pre class="line-numbers language-bash"><code class="language-bash">    11010011101100 000 <span class="token operator">&lt;</span>--- 数据序列末尾增加3位0
    1011               <span class="token operator">&lt;</span>--- 因子
    01100011101100 000 <span class="token operator">&lt;</span>--- XOR结果
     1011              <span class="token operator">&lt;</span>--- 因子
    00111011101100 000
      1011
    00010111101100 000
       1011
    00000001101100 000
           1011
    00000000110100 000
            1011
    00000000011000 000
             1011
    00000000001110 000
              1011
    00000000000101 000
               101 1
    -----------------
    00000000000000 100 <span class="token operator">&lt;</span>--- 3位余数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<ul>
<li><strong>[2] 集线器<code>(Hub)</code> vs. 交换器<code>(Switch)</code></strong></li>
</ul>
<p>以太网使用集线器或者交换器将帧从发出地传送到目的地。一台集线器或交换器上有多个端口，每个端口都可以连接一台计算机或其他设备。</p>
<p>集线器像一个广播电台。一台电脑将帧发送到集线器，集线器会将帧转发到所有其他的端口。每台计算机检查自己的 <code>MAC</code> 地址是不是符合 <code>DST</code>。如果不是，则保持沉默。集线器是比较早期的以太网设备。它有明显的缺陷：</p>
<ul>
<li>任意两台电脑的通信在同一个以太网上是公开的。所有连接在同一个集线器上的设备都能收听到别人在传输什么，这样很不安全。可以通过对信息加密提高安全性。</li>
<li>不允许多路同时通信。如果两台电脑同时向集线器发信，集线器会向所有设备发出“冲突”信息，提醒发生冲突。可以在设备上增加冲突检测算法(<code>collision detection</code>)：一旦设备发现有冲突，则随机等待一段时间再重新发送。</li>
</ul>
<p>交换器克服集线器的缺陷。交换器记录有各个设备的 <code>MAC</code> 地址。当帧发送到交换器时，交换器会检查 <code>DST</code>，然后将帧只发送到对应端口。交换器允许多路同时通信。由于交换器的优越性，交换器基本上取代了集线器。但比较老的以太网还有可能在使用集线器。</p>
<ul>
<li><strong>[3] WiFi</strong></li>
</ul>
<p><code>WiFi</code> 的工作方式与集线器连接下的以太网类似。一个 <code>WiFi</code> 设备会向所有的 <code>WiFi</code> 设备发送帧，其它的 <code>WiFi</code> 设备检查自己是否符合 <code>DST</code>。由于 <code>WiFi</code> 采取无线电信号，所以很难像交换器一样定向发送，所以 <code>WiFi</code> 的安全性很值得关注。<code>WiFi</code> 采用加密的方法来实现信息的安全性。早期的 <code>WEP</code> 加密方法非常脆弱，建议使用 <code>WPA</code> 或者 <code>WPA2</code> 加密方法。隐藏 <code>WiFi</code> 设备 <code>ID</code> 的方法不是很有用</p>
<ul>
<li><strong>[4] 总结陈述</strong></li>
</ul>
<p>我们深入了连接层协议的一些细节。连接层是物理与逻辑的接口，它的设计兼顾了物理需求(比如时钟复原，<code>CRC</code>)和逻辑需求(比如地址、数据)。由于连接层处于网络逻辑的底层，有许多基于连接层的攻击手法，这需要我们对连接层的工作方式有一定的了解，以设计出更好的网络安全策略。</p>
<hr>
<h2 id="3-网络层协议"><a href="#3-网络层协议" class="headerlink" title="3. 网络层协议"></a>3. 网络层协议</h2><h3 id="3-1-IP-接力赛-IP-ARP-RIP-和-BGP-协议"><a href="#3-1-IP-接力赛-IP-ARP-RIP-和-BGP-协议" class="headerlink" title="3.1 IP 接力赛 (IP, ARP, RIP 和 BGP 协议)"></a>3.1 <code>IP</code> 接力赛 (IP, ARP, <code>RIP</code> 和 BGP 协议)</h3><p>网络层(<code>network layer</code>)是实现互联网最重要的一层。正是在网络层面上，各个局域网根据 <code>IP</code> 协议相互连接，最终构成覆盖全球的 <code>Internet</code>。更高层的协议，无论是 <code>TCP</code> 还是 <code>UDP</code>，必须通过网络层的 <code>IP</code> 数据包(<code>datagram</code>)来传递信息。操作系统也会提供该层面的套接字(<code>socket</code>)，从而允许用户直接操作 <code>IP</code> 包。</p>
<p><code>IP</code> 数据包简称为 <code>IP</code> 包。它是符合 <code>IP</code> 协议的 <code>0/1</code> 序列。信息包含在这一序列中。<code>IP</code> 包分为头部(<code>header</code>)和数据(<code>Data</code>)两部分。数据部分是要传送的信息，头部是为了能够实现传输而附加的信息。这与以太网帧的头部功能相类似，如果对帧感到陌生，可参看小喇叭一文。</p>
<ul>
<li><strong>[1] <code>IP</code> 包的格式</strong></li>
</ul>
<p><code>IP</code> 协议可以分为 <code>IPv4</code> 和 <code>IPv6</code> 两种。<code>IPv6</code> 是改进版本，用于在未来取代 <code>IPv4</code> 协议。我们可以暂时忽略两者的区别，只以 <code>IPv4</code> 为例。下面是 <code>IPv4</code> 的格式。我们按照 <code>4 bytes</code> 为单位，将整个序列折叠，以便更好的显示。</p>
<p><img src="../images/learn-tcp-ip-protocol-20.png" alt="IPv4包 我们按照4 bytes将整个序列折叠，以便更好的显示"></p>
<p>与帧类似，<code>IP</code> 包的头部也有多个区域。我们将注意力放在红色的发出地和目的地。它们都是 <code>IP</code> 地址。<code>IPv4</code> 的地址为 <code>4 bytes</code> 的长度(也就是 <code>32</code> 位)。我们通常将 <code>IPv4</code> 的地址分为四个十进制的数，每个数的范围为 <code>0-255</code>，比如 <code>192.0.0.1</code> 就是一个 <code>IP</code> 地址。填写在 <code>IP</code> 包头部的是该地址的二进制形式。</p>
<p><code>IP</code> 地址是全球地址，它可以识别”社区”<code>(局域网)</code>和”房子”<code>(主机)</code>。这是通过将 <code>IP</code> 地址分类实现的。每个 <code>IP</code> 地址的 <code>32</code> 位分为前后两部分，第一部分用来区分局域网，第二个部分用来区分该局域网的主机。子网掩码(<code>Subnet Mask</code>)告诉我们这两部分的分界线，比如 <code>255.0.0.0</code>(也就是 <code>8</code> 个 <code>1</code> 和 <code>24</code> 个 <code>0</code>)表示前 <code>8</code> 位用于区分局域网，后 <code>24</code> 位用于区分主机。由于 <code>A</code>、<code>B</code>、<code>C</code> 分类是已经规定好的，所以当一个 <code>IP</code> 地址属于 <code>B</code> 类范围时，我们就知道它的前 <code>16</code> 位和后 <code>16</code> 位分别表示局域网和主机。</p>
<table>
<thead>
<tr>
<th><code>IP</code> class</th>
<th>From</th>
<th>To</th>
<th>Subnet Mask</th>
</tr>
</thead>
<tbody><tr>
<td>A</td>
<td>1.0.0.0</td>
<td>126.255.255.255</td>
<td>255.0.0.0</td>
</tr>
<tr>
<td>B</td>
<td>128.0.0.0</td>
<td>191.255.255.255</td>
<td>255.255.0.0</td>
</tr>
<tr>
<td>C</td>
<td>192.0.0.0</td>
<td>223.255.255.255</td>
<td>255.255.255.0</td>
</tr>
</tbody></table>
<ul>
<li><strong>[2] 网卡与路由器</strong></li>
</ul>
<p>邮差与邮局中说，<code>IP</code> 地址是分配给每个房子(计算机)的”邮编”。但这个说法并不精确。<code>IP</code> 地址实际上识别的是网卡。网卡是计算机的一个硬件，它在接收到网路信息之后，将信息交给计算机的 <code>CPU</code> 处理。当计算机需要发送信息的时，也要通过网卡发送。一台计算机可以有不只一个网卡，比如笔记本就有一个以太网卡和一个 <code>WiFi</code> 网卡。计算机在接收或者发送信息的时候，要先决定想要通过哪个网卡。</p>
<p><img src="../images/learn-tcp-ip-protocol-21.jpg" alt="NIC"></p>
<p>路由器(<code>router</code>)实际上就是一台配备有多个网卡的专用电脑。它让网卡接入到不同的网络中，这样，就构成在邮差与邮局中所说的邮局。比如下图中位于中间位置的路由器有两个网卡，地址分别为 <code>199.165.145.17</code> 和 <code>199.165.146.3</code>。它们分别接入到两个网络：<code>199.165.145</code> 和 <code>199.165.146</code>。</p>
<p><img src="../images/learn-tcp-ip-protocol-22.png" alt="TCP-IP协议森林"></p>
<ul>
<li><strong>[3] <code>IP</code> 包接力</strong></li>
</ul>
<p><code>IP</code> 包的传输要通过路由器的接力。每一个主机和路由中都存有一个路由表(<code>routing table</code>)。路由表根据目的地的 <code>IP</code> 地址，规定了等待发送的 <code>IP</code> 包所应该走的路线。就好像下图的路标，如果地址是“东京”，那么请转左；如果地址是“悉尼”，那么请向右。</p>
<p><img src="../images/learn-tcp-ip-protocol-23.jpg" alt="A real world routing table"></p>
<p>比如我们从主机 <code>145.17</code> 生成发送到 <code>146.21</code> 的 <code>IP</code> 包：铺开信纸，写好信的开头。剩下数据部分可以是 <code>TCP</code> 包，可以是 <code>UDP</code> 包，也可以是任意乱写的字，我们暂时不关心。注明目的地 <code>IP</code> 地址(<code>199.165.146.21</code>)和发出地 <code>IP</code> 地址(<code>199.165.145.17</code>)。主机 <code>145.17</code> 随后参照自己的路由表，看到路由表中的记录：</p>
<p>145.17 routing table (Genmask 为子网掩码，Iface 用于说明使用哪个网卡接口)</p>
<table>
<thead>
<tr>
<th>Destination</th>
<th>Gateway</th>
<th>Genmask</th>
<th>Iface</th>
</tr>
</thead>
<tbody><tr>
<td>199.165.145.0</td>
<td>0.0.0.0</td>
<td>255.255.255.0</td>
<td>eth0</td>
</tr>
<tr>
<td>0.0.0.0</td>
<td>199.165.145.17</td>
<td>0.0.0.0</td>
<td>eth0</td>
</tr>
</tbody></table>
<p>这里有两行记录：</p>
<ol>
<li>第一行，如果 <code>IP</code> 目的地是 <code>199.165.145.0</code> 这个网络的主机，那么只需要自己在 <code>eth0</code> 上的网卡直接传送(“本地社区”：直接送达)，不需要前往路由器(Gateway 0.0.0.0 = “本地送信”)。</li>
<li>第二行，所有不符合第一行的 <code>IP</code> 目的地，都应该送往 <code>Gateway</code> <code>199.165.145.17</code>，也就是中间路由器接入在 <code>eth0</code> 的网卡 <code>IP</code> 地址(邮局在 <code>eth0</code> 的分支)。</li>
</ol>
<p>我们的 <code>IP</code> 包目的地为 <code>199.165.146.21</code>，不符合第一行，所以按照第二行，发送到中间的路由器。主机 <code>145.17</code> 会将 <code>IP</code> 包放入帧的 <code>payload</code>，并在帧的头部写上 <code>199.165.145.17</code> 对应的 <code>MAC</code> 地址，这样，就可以按照小喇叭中的方法在局域网中传送了。</p>
<p>中间的路由器在收到 <code>IP</code> 包之后(实际上是收到以太协议的帧，然后从帧中的 <code>payload</code> 读取 <code>IP</code> 包)，提取目的地 <code>IP</code> 地址，然后对照自己的路由表：</p>
<table>
<thead>
<tr>
<th>Destination</th>
<th>Gateway</th>
<th>Genmask</th>
<th>Iface</th>
</tr>
</thead>
<tbody><tr>
<td>199.165.145.0</td>
<td>0.0.0.0</td>
<td>255.255.255.0</td>
<td>eth0</td>
</tr>
<tr>
<td>199.165.146.0</td>
<td>0.0.0.0</td>
<td>255.255.255.0</td>
<td>eth1</td>
</tr>
<tr>
<td>0.0.0.0</td>
<td>199.165.146.8</td>
<td>0.0.0.0</td>
<td>eth1</td>
</tr>
</tbody></table>
<p>从前两行我们看到，由于路由器横跨 <code>eth0</code> 和 <code>eth1</code> 两个网络，它可以直接通过 <code>eth0</code> 和 <code>eth1</code> 上的网卡直接传送 <code>IP</code> 包。第三行表示，如果是前面两行之外的 <code>IP</code> 地址，则需要通过 <code>eth1</code>，送往 <code>199.165.146.8</code>(右边的路由器)。我们的目的地符合第二行，所以将 <code>IP</code> 放入一个新的帧中，在帧的头部写上 <code>199.165.146.21</code> 的 <code>MAC</code> 地址，直接发往主机 <code>146.21</code>。</p>
<p>在 <code>Linux</code> 下，可以使用 <code>route -n</code> 或 <code>ip route</code> 来查看路由表。<code>route</code> 命令基本上是所有 <code>Linux</code> 系统自带的命令，不过现在有更强悍的网络命令集 <a href="http://www.linuxfoundation.org/collaborate/workgroups/networking/iproute2" target="_blank" rel="noopener">iproute2</a>。它完全可以替代 <code>ifconfig</code>, <code>route</code> 等命令，比如查看 <code>ip address</code> 和 <code>route table</code>。</p>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token variable"><span class="token variable">`</span>IP<span class="token variable">`</span></span> addr show enp0s5
2: enp0s5: <span class="token operator">&lt;</span>BROADCAST,MULTICAST,UP,LOWER_UP<span class="token operator">></span> mtu 1500 qdisc pfifo_fast state UP qlen 1000
    link/ether 00:1c:42:bd:ea:3d brd ff:ff:ff:ff:ff:ff
        inet 10.211.55.6/24 brd 10.211.55.255 scope global enp0s5
    inet6 fdb2:2c26:f4e4:0:12c:42ff:fedb:ae3d/64 scope global dynamic
        valid_lft 2591961sec preferred_lft 604761sec
    inet6 fe80::12c:42ff:fedb:ae3d/64 scope <span class="token function">link</span>
        valid_lft forever preferred_lft forever<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<pre class="line-numbers language-bash"><code class="language-bash">$ <span class="token variable"><span class="token variable">`</span>IP<span class="token variable">`</span></span> route
default via 10.211.55.1 dev enp0s5  metric 2
10.211.55.0/24 dev enp0s5  proto kernel  scope <span class="token function">link</span>  src 10.211.55.6  metric 2
127.0.0.0/8 via 127.0.0.1 dev lo<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><code>IP</code> 包可以进一步接力，到达更远的主机。<code>IP</code> 包从主机出发，根据沿途路由器的路由表指导，在路由器间接力。<code>IP</code> 包最终到达某个路由器，这个路由器与目标主机位于一个局域网中，可以直接建立连接层的通信。最后，<code>IP</code> 包被送到目标主机。这样一个过程叫做 <code>routing</code>(我们就叫 <code>IP</code> 包接力好了，路由这个词实在是混合了太多的意思)。</p>
<p>整个过程中，<code>IP</code> 包不断被主机和路由封装入帧(信封)并拆开，然后借助连接层，在局域网的各个 NIC 之间传送帧。整个过程中，我们的 <code>IP</code> 包的内容保持完整，没有发生变化。最终的效果是一个 <code>IP</code> 包从一个主机传送到另一个主机。利用 <code>IP</code> 包，我们不需要去操心底层(比如连接层)发生了什么。</p>
<ul>
<li><strong>[4] ARP 协议</strong></li>
</ul>
<p>在上面的过程中，我们实际上假设了，每一台主机和路由都能了解局域网内的 <code>IP</code> 地址和 <code>MAC</code> 地址的对应关系，这是实现 <code>IP</code> 包封装(<code>encapsulation</code>)到帧的基本条件。<code>IP</code> 地址与 <code>MAC</code> 地址的对应是通过 <code>ARP</code> 协议传播到局域网的每个主机和路由。每一台主机或路由中都有一个 <code>ARP cache</code>，用以存储局域网内 <code>IP</code> 地址和 <code>MAC</code> 地址如何对应。</p>
<p><code>ARP</code> 协议介于连接层和网络层之间，<code>ARP</code> 包需要包裹在一个帧中。它的工作方式如下：主机会发出一个 <code>ARP</code> 包，该 <code>ARP</code> 包中包含有自己的 <code>IP</code> 地址和 <code>MAC</code> 地址。通过 <code>ARP</code> 包，主机以广播的形式询问局域网上所有的主机和路由：我是 <code>IP</code> 地址<code>xxxx</code>，我的 <code>MAC</code> 地址是 <code>xxxx</code>，有人知道 <code>199.165.146.4</code> 的 <code>MAC</code> 地址吗？拥有该 <code>IP</code> 地址的主机会回复发出请求的主机：哦，我知道，这个 <code>IP</code> 地址属于我的一个 <code>NIC</code>，它的 <code>MAC</code> 地址是 <code>xxxxxx</code>。由于发送 <code>ARP</code> 请求的主机采取的是广播形式，并附带有自己的 <code>IP</code> 地址和 <code>MAC</code> 地址，其他的主机和路由会同时检查自己的 <code>ARP cache</code>，如果不符合，则更新自己的 <code>ARP cache</code>。</p>
<p>这样，经过几次 <code>ARP</code> 请求之后，<code>ARP cache</code> 会达到稳定。如果局域网上设备发生变动，<code>ARP</code> 重复上面过程。</p>
<ul>
<li><strong>[5] 路由表的生成</strong></li>
</ul>
<p>之前的信息传递基于一个假设：每个人手里都有份准确的地图。用计算机的话来说，就是每个主机和路由上都已经有了合理的路由表。这个路由表描述了网络上的路径信息。如果你了解自己的网络连接，可以手写自己主机的路由表。但是，一个路由器可能有多个出口，所以路由表可能会很长。更重要的是，周围连接的其他路由器可能发生变动(比如新增路由器或者路由器坏掉)，我们就需要路由表能及时将交通导向其他的出口。我们需要一种更加智能的探测周围的网络拓扑结构，并自动生成路由表。</p>
<p><img src="../images/learn-tcp-ip-protocol-24.png" alt="TCP-IP协议森林"></p>
<p>我们以北京地铁为例子。如果从机场前往朝阳门，那么可以采取 <code>2</code> 号航站楼-&gt;&gt;三元桥-&gt;&gt;东直门-&gt;&gt;朝阳门。<code>2</code> 号航站楼和朝阳门分别是出发和目的主机。而三元桥和东直门为中间的两个路由器。如果三元桥-&gt;&gt;东直门段因为维修停运，我们需要更改三元桥的路由表，从而给前往朝阳门的乘客(<code>IP</code> 包)指示：请走如下路线三元桥-&gt;&gt;芍药居。然后依照芍药居的路由表前往朝阳门(芍药居-&gt;&gt;东直门-&gt;&gt;朝阳门)。</p>
<p>路由表的生成同样基于网络。一种用来生成路由表的协议是 <code>RIP</code>。它通过“距离”来决定路由表，所以属于 <code>distance-vector protocol</code>。对于 <code>RIP</code> 来说，所谓的“距离”是从出发地到目的地途径的路由器数目(<code>hop number</code>)。</p>
<p><code>RIP</code> 的基本逻辑是：如果 <code>A</code> 距离 <code>B</code> 为 <code>6</code>，而我距离 <code>A</code> 为 <code>1</code>，那么我途径 <code>A</code> 到 <code>B</code> 的距离为 <code>7</code>。</p>
<p>比如上面从机场到朝阳门，按照</p>
<pre class="line-numbers language-bash"><code class="language-bash">    2号航站楼 -<span class="token operator">>></span> 三元桥 -<span class="token operator">>></span> 东直门 -<span class="token operator">>></span> 朝阳门路线<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>途径上有两个路由器，因此从起点到终点的距离为 <code>2</code>。我们最初可以手动生成三元桥的路由表。随后，根据 <code>RIP</code> 协议，三元桥向周围的路由器和主机广播自己前往各个 <code>IP</code> 的距离(比如到机场=0，团结湖=0，国贸=1，望京西=1，建国门=2)。收到 <code>RIP</code> 包的路由器和主机根据 <code>RIP</code> 包和自己到发送 <code>RIP</code> 包的主机的距离，算出自己前往各个 <code>IP</code> 的距离。东直门与三元桥的距离为 1。东直门收到三元桥的 <code>RIP</code> 包(到机场的距离为 0)，那么东直门途径三元桥前往机场的距离为 1+0=1。如果东直门自己的 <code>RIP</code> 记录都比这个远(比如东直门-&gt;&gt;芍药居-&gt;&gt;三元桥-&gt;&gt;机场= 2)。那么东直门更改自己的路由表：前往机场的交通都发往三元桥而不是芍药居。如果东直门自身的 <code>RIP</code> 记录并不差，那么东直门保持路由表不变。在各个点不断重复<strong>RIP 广播/计算距离/更新路由表</strong>的过程，最终所有的主机和路由器都能生成最合理的路由表。</p>
<p><code>RIP</code> 出于技术上的原因，认为距离超过 <code>15</code> 的 <code>IP</code> 不可到达。所以 <code>RIP</code> 更多用于互联网的一部分(比如整个中国电信的网络)。这样一个互联网的部分往往属于同一个 <code>ISP</code> 或者有同一个管理机构，所以叫做自治系统。自治系统内部的主机和路由根据通向外部的边界路由器来和其它的自治系统通信。各个边界路由器之间通过 <code>BGP</code> 来生成自己前往其它 <code>AS</code> 的路由表。自治系统内部则参照边界路由器，使用 <code>RIP</code> 来决定路由表。<code>BGP</code> 的基本工作过程与 <code>RIP</code> 类似，但在考虑距离的同时，也权衡比如政策、连接性能等其他因素，再决定交通的走向(路由表)。</p>
<ul>
<li><strong>[6] 总结陈述</strong></li>
</ul>
<p>我们一开始讲述了 <code>IP</code> 包根据路由表进行接力的过程。为了顺利实现接力，我们又进一步深入到 <code>ARP</code> 和 <code>RIP/BGP</code>。这三个协议都协助了 <code>IP</code> 传输。<code>ARP</code> 让每台电脑和路由器知道自己局域网内 <code>IP</code> 地址和 <code>MAC</code> 地址的对应关系，从而顺利实现 <code>IP</code> 包到帧的封装。<code>RIP</code> 协议可以生成自治系统内部合理的路由表。<code>BGP</code> 协议可以生成自治系统外部的路由表。</p>
<p>在整个过程中，我们都将注意力放在了 <code>IP</code> 包大的传输过程中，而故意忽略一些细节。 而上面的 <code>IP</code> 接力过程适用于 <code>IPv6</code>。</p>
<hr>
<h3 id="3-2-地址耗尽危机-IPv4-与-IPv6-地址"><a href="#3-2-地址耗尽危机-IPv4-与-IPv6-地址" class="headerlink" title="3.2 地址耗尽危机 (IPv4 与 IPv6 地址)"></a>3.2 地址耗尽危机 (IPv4 与 IPv6 地址)</h3><p><code>IP</code> 地址是 <code>IP</code> 协议的重要组成部分，它可以识别接入互联网中的任意一台设备。在 <code>IP</code> 接力中，我们已经看到，<code>IP</code> 包的头部写有出发地和目的地的 <code>IP</code> 地址。<code>IP</code> 包上携带的 <code>IP</code> 地址和路由器相配合，最终允许 <code>IP</code> 包从互联网的一台电脑传送到另一台。</p>
<p>在 <code>IP</code> 接力中，我们是以 <code>IPv4</code> 为例说明 <code>IP</code> 包的格式的。<code>IPv4</code> 和 <code>IPv6</code> 是先后出现的两个 <code>IP</code> 协议版本。<code>IPv4</code> 的地址就是一个 <code>32</code> 位的 <code>0/1</code> 序列，比如 <strong>11000000 00000000 0000000 00000011</strong>。为了方便人类记录和阅读，我们通常将 <code>32</code> 位 <code>0/1</code> 分成 <code>4</code> 段 <code>8</code> 位序列，并用 <code>10</code> 进制来表示每一段这样，一段的范围就是 <code>0</code> 到 <code>255</code>。段与段之间以 <code>.</code> 分隔。比如上面的地址可以表示成为 <code>192.0.0.3</code>。<code>IPv6</code> 地址是 <code>128</code> 位 <code>0/1</code> 序列，它也按 <code>8</code> 位分割，以 <code>16</code> 进制来记录每一段。使用 <code>16</code> 进制而不是 <code>10</code> 进制，能让写出来的 <code>IPv6</code> 地址短一些。段与段之间以 <code>:</code> 分隔。</p>
<ul>
<li><strong>[1] <code>IP</code> 地址的分配</strong></li>
</ul>
<p><code>IP</code> 地址的分配是一个政策性的问题。<code>ICANN</code>是 <code>Internet</code> 的中心管理机构。<code>ICANN</code> 的 <code>IANA</code>部门负责将 <code>IP</code> 地址分配给 <code>5</code> 个区域性的互联网注册机构(<code>RIR</code>)，比如 <code>APNIC</code>，它负责亚太地区的 <code>IP</code> 分配。然后 <code>RIR</code> 将地址进一步分配给当地的 <code>ISP</code>，比如中国电信和中国网通。<code>ISP</code> 再根据自己的情况，将 <code>IP</code> 地址分配给机构或者直接分配给用户，比如将 <code>A</code> 类地址分配给一个超大型机构，而将 <code>C</code> 类地址分配给一个网吧。机构可以进一步在局域网内部分配 <code>IP</code> 地址给各个主机。(<code>A</code>/<code>B</code>/<code>C</code> 类地址请参阅 <code>IP</code> 接力)</p>
<p><img src="../images/learn-tcp-ip-protocol-30.png" alt="5个RIR的分管区域"></p>
<p>并不是所有的地址都会被分配。一些地址被预留，用于广播、测试、私有网络使用等。这些地址被称为专用地址。你可以查询 <code>RFC5735</code> 来了解哪些地址是专用地址。这个文档是 <code>RFC</code> 文档中的一个。</p>
<p><code>RFC</code> 是一系列的技术文档，用于记录 <code>Internet</code> 相关的技术和协议规定。每一个 <code>RFC</code> 文件都有一个固定的编号。它们是互联网的一个重要财产。你可以通过 <code>http://www.rfc-editor.org/</code> 来查找 <code>RFC</code> 文件。</p>
<ul>
<li><strong>[2] IPv4 地址耗尽</strong></li>
</ul>
<p>由于 <code>IPv4</code> 协议的地址为 <code>32</code> 位，所以它可以提供大约 <code>40</code> 亿个地址。如果地球人每人一个 <code>IP</code> 地址的话，<code>IPv4</code> 地址已经远远不够。更何况，人均持有的入网设备可能要远多于一个，下图中显示了一个家庭对 <code>IP</code> 地址的需求，这种需求量已经相当常见了：<br>￼<br><img src="../images/learn-tcp-ip-protocol-31.png" alt="We need more `IP` address！"></p>
<p>下图显示了各大洲 RIR 的 IPv4 地址耗尽日期 (IANA 已经将所有的 <code>IP</code> 分配给各个 RIR)：<br>￼<br><img src="../images/learn-tcp-ip-protocol-32.png" alt="5个RIR区域的预计耗尽日期"></p>
<p>尽管一些技术措施，比如 <code>NAT</code> 技术，可以为更多的网络设备提供地址，从而减缓了情况的紧急程度，但 <code>IPv4</code> 地址耗尽的一天终究还是会很快到来。很明显，我们需要更多的 <code>IP</code> 地址，以满足爆炸式增长的互联网设备对 <code>IP</code> 地址的需求。<br>￼<br><img src="../images/learn-tcp-ip-protocol-33.jpg" alt="Too much stuff for IPv4"></p>
<ul>
<li><strong>[3] 更长=更好</strong></li>
</ul>
<p><code>IPv6</code> 协议的地址最重要的改进就是：加长。<code>IPv6</code> 的地址为 <code>128</code> 位。准确的说，<code>IPv4</code> 有 <code>4,294,967,296</code> 个地址，而 <code>IPv6</code> 有 <strong>340,282,366,920,938,463,374,607,431,768,211,456</strong> 个地址。这是怎样一个概念呢？我们可以大概计算一下</p>
<p>地球表面积大约为 <code>510,067,866,000,000</code> 平方米。在一平方厘米，也就是大约指甲盖大小的面积内，我们可以有将近 <code>7000</code> 个 <code>IP</code> 地址！所以在短期的时间内，我们应该不会看到 <code>IPv6</code> 被用尽的尴尬(不排除在未来计算机以分子尺寸出现，那么我们就会有 <code>IPv6</code> 耗尽危机了)。<code>IPv6</code> 是解决 <code>IP</code> 地址危机的最终方案。</p>
<ul>
<li><strong>[4] 总结陈述</strong></li>
</ul>
<p><code>IPv4</code> 地址正在耗尽，而 <code>IPv6</code> 通过更长的序列提供了更多的 <code>IP</code> 地址。<code>IPv4</code> 向 <code>IPv6</code> 的迁移正在发生。阻碍迁移的过程的主要在于 <code>IPv4</code> 和 <code>IPv6</code> 格式的不兼容性。老的路由器支持 <code>IPv4</code> 格式的 <code>IP</code> 包，但它们无法理解 <code>IPv6</code> 格式的 <code>IP</code> 包。所以这一迁移过程必然要伴随者设备的更新。然而，我们的许多互联网资产都是建立在 <code>IPv4</code> 网络上的，不可能一夜之间停止 <code>IPv4</code> 网络的服务而整体迁移到 <code>IPv6</code> 网络中。这一迁移过程注定充满坎坷。</p>
<hr>
<h3 id="3-3-我尽力-IP-协议详解"><a href="#3-3-我尽力-IP-协议详解" class="headerlink" title="3.3 我尽力 (IP 协议详解)"></a>3.3 我尽力 (IP 协议详解)</h3><p><code>IP</code> 地址是 <code>IP</code> 协议的重要组成部分，但远非 <code>IP</code> 协议的全部。我们再来看一看 <code>IP</code> 协议的具体细节和设计哲学。</p>
<ul>
<li><strong>[1] IPv4 与 IPv6 头部的对比</strong></li>
</ul>
<p>我们已经在 <code>IP</code> 接力中介绍过，一个 <code>IP</code> 包分为头部(<code>header</code>)和数据(<code>payload/data</code>)两部分。头部是为了实现 <code>IP</code> 通信必须的附加信息，数据是 <code>IP</code> 通信所要传送的信息。<br>￼<br><img src="../images/learn-tcp-ip-protocol-40.gif" alt="TCP-IP协议森林"></p>
<ul>
<li>黄色区域 (同名区域)</li>
</ul>
<p>我们看到，三个黄色区域跨越了 <code>IPv4</code> 和 <code>IPv6</code>。<code>Version</code>(4 位)用来表明 <code>IP</code> 协议版本，是 <code>IPv4</code> 还是 <code>IPv6</code>(IPv4, Version=0100; IPv6, Version=0110)。<code>Source Adrresss</code> 和 <code>Destination Address</code> 分别为发出地和目的地的 <code>IP</code>地址。</p>
<ul>
<li>蓝色区域（名字发生变动的区域）</li>
</ul>
<p><code>Time to Live</code> 存活时间(<code>Hop Limit in IPv6</code>)。<code>Time to Live</code> 最初是表示一个 <code>IP</code> 包的最大存活时间：如果 <code>IP</code> 包在传输过程中超过 <code>Time to Live</code>，那么 <code>IP</code> 包就作废。后来，<code>IPv4</code> 的这个区域记录一个整数(比如 <code>30</code>)，表示在 <code>IP</code> 包接力过程中最多经过 <code>30</code> 个路由接力，如果超过 <code>30</code> 个路由接力，那么这个 <code>IP</code> 包就作废。<code>IP</code> 包每经过一个路由器，路由器就给 <code>Time to Live</code> 减一。当一个路由器发现 <code>Time to Live</code> 为 <code>0</code> 时，就不再发送该 <code>IP</code> 包。<code>IPv6</code> 中的 <code>Hop Limit</code> 区域记录的也是最大路由接力数，与 <code>IPv4</code> 的功能相同。<code>Time to Live</code>/<code>Hop Limit</code> 避免了 <code>IP</code> 包在互联网中无限接力。</p>
<p><code>Type of Service</code> 服务类型<code>(Traffic Class in IPv6</code>)。<code>Type of Service</code> 最初是用来给 <code>IP</code> 包分优先级，比如语音通话需要实时性，所以它的 <code>IP</code> 包应该比 <code>Web</code> 服务的 <code>IP</code> 包有更高的优先级。然而，这个最初不错的想法没有被微软采纳。在 <code>Windows</code> 下生成的 <code>IP</code> 包都是相同的最高优先级，所以在当时造成 <code>Linux</code> 和 <code>Windows</code> 混合网络中，<code>Linux</code> 的 <code>IP</code> 传输会慢于 <code>Windows</code> (仅仅是因为 <code>Linux</code> 更加守规矩！)。后来，<code>Type of Service</code> 被实际分为两部分：<code>Differentiated Service Field</code> (<code>DS</code>, 前 6 位)和 <code>Explicit Congestion Notification</code> (<code>ECN</code>, 后 2 位)，前者依然用来区分服务类型，而后者用于表明 <code>IP</code> 包途径路由的交通状况。<code>IPv6</code> 的 <code>Traffic Class</code> 也被如此分成两部分。通过 <code>IP</code> 包提供不同服务的想法，并针对服务进行不同的优化的想法已经产生很久了，但具体做法并没有形成公认的协议。比如 <code>ECN</code> 区域，它用来表示 <code>IP</code> 包经过路径的交通状况。如果接收者收到的 <code>ECN</code> 区域显示路径上的很拥挤，那么接收者应该作出调整。但在实际上，许多接收者都会忽视<code>ECN</code> 所包含的信息。交通状况的控制往往由更高层的比如 <code>TCP</code> 协议实现。</p>
<p><code>Protocol</code> 协议(<code>Next Header in IPv6</code>)。<code>Protocol</code> 用来说明 <code>IP</code> 包 <code>Payload</code> 部分所遵循的协议，也就是 <code>IP</code> 包之上的协议是什么。它说明了 <code>IP</code> 包封装的是一个怎样的高层协议包(TCP? UDP?)。</p>
<p><code>Total Length</code>, 以及 <code>IPv6</code> 中 <code>Payload Length</code> 的讨论要和 <code>IHL</code> 区域放在一起，我们即将讨论。</p>
<ul>
<li>红色区域 (IPv6 中删除的区域)</li>
</ul>
<p>我们看一下 <code>IPv4</code> 和 <code>IPv6</code> 的长度信息。<code>IPv4</code> 头部的长度。在头部的最后，是 <code>options</code>。每个 <code>options</code> 有 <code>32</code> 位，是选填性质的区域。一个 <code>IPv4</code> 头部可以完全没有 <code>options</code> 区域。不考虑 <code>options</code> 的话，整个 <code>IPv4</code> 头部有 <code>20 bytes</code>(上面每行为 <code>4 bytes</code>)。但由于有 <code>options</code> 的存在，整个头部的总长度是变动的。我们用 <code>IHL</code>(Internet Header Length)来记录头部的总长度，用 <code>Total Length</code> 记录整个 <code>IP</code> 包的长度。<code>IPv6</code> 没有 <code>options</code>，它的头部是固定的长度 <code>40 bytes</code>，所以 <code>IPv6</code> 中并不需要 <code>IHL</code> 区域。<code>Payload Length</code> 用来表示 <code>IPv6</code> 的数据部分的长度。整个 <code>IP</code> 包为 <code>40 bytes + Payload Length</code>。</p>
<p><code>IPv4</code> 中还有一个 <code>Header Checksum</code> 区域。这个 <code>checksum</code> 用于校验 <code>IP</code> 包的头部信息。<code>Checksum</code> 与之前在小喇叭中提到的 <code>CRC</code> 算法并不相同。<code>IPv6</code> 则没有 <code>checksum</code> 区域。<code>IPv6</code> 包的校验依赖高层的协议来完成，这样的好处是免去了执行 <code>checksum</code> 校验所需要的时间，减小了网络延迟 (<code>latency</code>)。</p>
<p><code>Identification</code>, <code>flags</code> 和 <code>fragment offset</code>，这三个包都是为碎片化(<code>fragmentation</code>)服务的。碎片化是指一个路由器将接收到的 <code>IP</code> 包分拆成多个 <code>IP</code> 包传送，而接收这些“碎片”的路由器或者主机需要将“碎片”重新组合(<code>reassembly</code>)成一个 <code>IP</code> 包。不同的局域网所支持的最大传输单元(<code>MTU</code>, <code>Maximum Transportation Unit</code>)不同。如果一个 <code>IP</code> 包的大小超过了局域网支持的 <code>MTU</code>，就需要在进入该局域网时碎片化传输(就好像方面面面饼太大了，必须掰碎才能放进碗里)。碎片化会给路由器和网络带来很大的负担。最好在 <code>IP</code> 包发出之前探测整个路径上的最小 <code>MTU</code>，<code>IP</code> 包的大小不超过该最小 <code>MTU</code>，就可以避免碎片化。<code>IPv6</code> 在设计上避免碎片化。每一个 <code>IPv6</code> 局域网的 <code>MTU</code> 都必须大于等于 <code>1280 bytes</code>。<code>IPv6</code> 的默认发送 <code>IP</code> 包大小为 <code>1280 bytes</code>。</p>
<p><img src="../images/learn-tcp-ip-protocol-41.jpg" alt="令人痛苦的碎片化"></p>
<ul>
<li>绿色区域 (IPv6 新增区域)</li>
</ul>
<p><code>Flow Label</code> 是 <code>IPv6</code> 中新增的区域。它被用来提醒路由器来重复使用之前的接力路径。这样 <code>IP</code> 包可以自动保持出发时的顺序。这对于流媒体之类的应用有帮助。<code>Flow label</code> 的进一步使用还在开发中。</p>
<ul>
<li><strong>[2] “我尽力”</strong></li>
</ul>
<p><code>IP</code> 协议在产生时是一个松散的网络，这个网络由各个大学的局域网相互连接成的，由一群碰头垢面的 <code>Geek</code> 维护。所以，<code>IP</code> 协议认为自己所处的环境是不可靠(<code>unreliable</code>)的：诸如路由器坏掉、实验室失火、某个 <code>PhD</code> 踢掉电缆之类的事情随时会发生。<br>￼<br><img src="../images/learn-tcp-ip-protocol-42.jpg" alt="不靠谱的网络"></p>
<p>这样的凶险环境下，<code>IP</code> 协议提供的传送只能是“我尽力” (<code>best effort</code>)式的。所谓的“我尽力”，其潜台词是，如果事情出错不要怪我，我只是答应了尽力，可没保证什么。所以，如果 <code>IP</code> 包传输过程中出现错误(比如 <code>checksum</code>对不上，比如交通太繁忙，比如超过 <code>Time to Live</code>)，根据 <code>IP</code> 协议，你的 <code>IP</code> 包会直接被丢掉。<code>Game Over</code>, 不会再有进一步的努力来修正错误。<code>Best effort</code> 让 <code>IP</code> 协议保持很简单的形态。更多的质量控制交给高层协议处理，<code>IP</code> 协议只负责有效率的传输。</p>
<p>(多么不负责任的邮递系统)</p>
<p>“效率优先”也体现在 <code>IP</code> 包的顺序(<code>order</code>)上。即使出发地和目的地保持不变，<code>IP</code> 协议也不保证 <code>IP</code> 包到达的先后顺序。我们已经知道，<code>IP</code> 接力是根据 routing table 决定接力路线的。如果在连续的 <code>IP</code> 包发送过程中，routing table 更新(比如有一条新建的捷径出现)，那么后发出的 <code>IP</code> 包选择走不一样的接力路线。如果新的路径传输速度更快，那么后发出的 <code>IP</code> 包有可能先到。这就好像是多车道的公路上，每辆车都在不停变换车道，最终所有的车道都塞满汽车。这样可以让公路利用率达到最大。</p>
<p><img src="../images/learn-tcp-ip-protocol-43.jpg" alt="“插队”"></p>
<p><code>IPv6</code> 中的 <code>Flow Label</code> 可以建议路由器将一些 <code>IP</code> 包保持一样的接力路径。但这只是“建议”，路由器可能会忽略该建议。</p>
<ul>
<li><strong>[3] Header Checksum 算法</strong></li>
</ul>
<p><code>Header Checksum</code> 区域有 <code>16</code> 位。它是这样获得的，从 <code>header</code> 取得除 <code>checksum</code> 之外的 <code>0/1</code> 序列，比如：</p>
<p><code>9194 8073 0000 4000 4011 C0A8 0001 C0A8 00C7</code> (十六进制 hex, 这是一个为演示运算过程而设计的 header)</p>
<p>按照十六位(也就是 <code>4</code> 位 <code>hex</code>)分割整个序列。将分割后的各个 <code>4</code> 位 <code>hex</code> 累积相加。如果有超过 <code>16</code> 位的进位出现，则将进位加到后 <code>16</code> 位结果的最后一位：</p>
<pre class="line-numbers language-bash"><code class="language-bash">      Binary                Hex
      1001000110010100      9194
    + 1000000001110011      8073
      ----------------
    1 0001001000000111     11207
    +                1
      ----------------
      0001001000001000      1208<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>上面的计算叫做 <code>one's complement sum</code>。求得所有十六位数的和，</p>
<p><code>one's complement sum(4500, 0073, 0000, 4000, 4011, C0A8, 0001, C0A8, 00C7) = 1433</code></p>
<p>然后，将 <code>1433</code> 的每一位取反(0-&gt;1, 1-&gt;0)， 就得到 <code>checksum</code>：<code>EBCC</code>。这样，我们的 <code>header</code> 就是:</p>
<pre class="line-numbers language-bash"><code class="language-bash">    9194 8073 0000 4000 4011 EBCC C0A8 0001 C0A8 00C7<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p><code>IP</code> 包的接收方在接收到 <code>IP</code> 包之后，可以求上面各个 <code>16</code> 位数的 <code>one's complement sum</code>，应该得到 <code>FFFF</code>。如果不是 <code>FFFF</code>，那么 <code>header</code> 是不正确的，整个 <code>IP</code> 包会被丢弃。再次提醒，示例所用的 <code>IP header</code> 不是真实的 <code>header</code>，它只是起演示算法的作用。</p>
<ul>
<li><strong>[4] 总结陈述</strong></li>
</ul>
<p>每个网络协议的形成都有其历史原因。比如 <code>IP</code> 协议是为了将各个分散的实验室网络连接起来。由于当时的网络很小，所以 <code>IPv4</code>(<code>IPv4</code> 产生与 <code>70</code> 年代)的地址总量为 <code>40</code> 亿。尽管当时被认为是很大的数字，但数字浪潮很快带来了地址耗尽危机。<code>IPv6</code> 的主要目的是增加 <code>IPv4</code> 的地址容量，但同时根据 <code>IPv4</code> 的经验和新时代的技术进步进行改进，比如避免碎片化，比如取消 <code>checksum</code> (由于高层协议 <code>TCP</code> 的广泛使用)。网络协议技术上并不复杂，更多的考量是政策性的。</p>
<p><code>IP</code> 协议是<strong>“Best Effort”</strong>式的，<code>IP</code> 传输是不可靠的。但这样的设计成就了 <code>IP</code> 协议的效率。</p>
<hr>
<h3 id="3-4-瑞士军刀-ICMP-协议"><a href="#3-4-瑞士军刀-ICMP-协议" class="headerlink" title="3.4 瑞士军刀 (ICMP 协议)"></a>3.4 瑞士军刀 (ICMP 协议)</h3><p>到现在为止，我们讲解了网络层中最重要的 <code>IP</code> 协议(参考协议森林)。IP 协议的一个重要补充是是 <code>ICMP</code> 协议。</p>
<ul>
<li><strong>[1] ICMP 协议</strong></li>
</ul>
<p><code>ICMP</code>(Internet Control Message Protocol)是介于网络层和传输层的协议。它的主要功能是传输网络诊断信息。</p>
<p><img src="../images/learn-tcp-ip-protocol-50.jpg" alt="TCP-IP协议森林"></p>
<p><code>ICMP</code> 传输的信息可以分为两类，一类是错误(<code>error</code>)信息，这一类信息可用来诊断网络故障。我们已经知道，<code>IP</code> 协议的工作方式是<strong>“Best Effort”</strong>，如果 <code>IP</code> 包没有被传送到目的地，或者 <code>IP</code> 包发生错误，<code>IP</code> 协议本身不会做进一步的努力。但上游发送 <code>IP</code> 包的主机和接力的路由器并不知道下游发生了错误和故障，它们可能继续发送 <code>IP</code> 包。通过 <code>ICMP</code> 包，下游的路由器和主机可以将错误信息汇报给上游，从而让上游的路由器和主机进行调整。需要注意的是，<code>ICMP</code> 只提供特定类型的错误汇报，它不能帮助 <code>IP</code> 协议成为“可靠”(<code>reliable</code>)的协议。另一类信息是咨询(<code>Informational</code>)性质的，比如某台计算机询问路径上的每个路由器都是谁，然后各个路由器同样用 <code>ICMP</code> 包回答。</p>
<p><code>ICMP</code> 基于 <code>IP</code> 协议。也就是说，一个 <code>ICMP</code> 包需要封装在 <code>IP</code> 包中，然后在互联网传送。<code>ICMP</code> 是 <code>IP</code> 套装的必须部分，也就是说，任何一个支持<code>IP</code> 协议的计算机，都要同时实现 <code>ICMP</code>。<code>ICMP</code> 包的结构：</p>
<p><img src="../images/learn-tcp-ip-protocol-51.png" alt="A bunch of Types"></p>
<p><code>ICMP</code> 包都会有 <code>Type</code>, <code>Code</code> 和 <code>Checksum</code> 三部分。<code>Type</code> 表示 <code>ICMP</code> 包的大的类型，而 <code>Code</code> 是一个 <code>Type</code> 之内细分的小类型。针对不同的错误信息或者咨询信息，会有不同的 <code>Type</code> 和 <code>Code</code>。从上面我们可以看到，<code>ICMP</code> 支持的类型非常多，就好像瑞士军刀一样，有各种各样的功能。<code>Checksum</code> 与 <code>IP</code> 协议的 <code>header checksum</code> 相类似，但与 <code>IP</code> 协议中 <code>checksum</code> 只校验头部不同，这里的 <code>Checksum</code> 所校验的是整个 <code>ICMP</code> 包(包括头部和数据)。</p>
<p><img src="../images/learn-tcp-ip-protocol-52.jpg" alt="TCP-IP协议森林"></p>
<p>余下的 <code>ICMP</code> 包格式根据不同的类型不同。另一方面，<code>ICMP</code> 包通常是由某个 <code>IP</code> 包触发的。这个触发 <code>IP</code> 包的头部和一部份数据会被包含在 <code>ICMP</code> 包的数据部分。<code>ICMP</code> 协议是实现 <code>ping</code> 命令和 <code>traceroute</code> 命令的基础。这两个工具常用于网络排错。</p>
<ul>
<li><p><strong>[2] 常见的 ICMP 包类型</strong></p>
</li>
<li><p>回音</p>
</li>
</ul>
<p>回音(<code>Echo</code>)属于咨询信息。<code>ping</code> 命令就是利用了该类型的 <code>ICMP</code> 包。当使用 <code>ping</code> 命令的时候，将向目标主机发送 Echo-询问类型的 <code>ICMP</code> 包，而目标主机在接收到该 <code>ICMP</code> 包之后，会回复 <code>Echo</code>-回答类型的 <code>ICMP</code> 包，并将询问 ICMP 包包含在数据部分。<code>ping</code> 命令是我们进行网络排查的一个重要工具。如果一个 <code>IP</code> 地址可以通过 <code>ping</code> 命令收到回复，那么其他的网络协议通信方式也很有可能成功。</p>
<ul>
<li>源头冷却</li>
</ul>
<p>源头冷却(<code>source quench</code>)属于错误信息。如果某个主机快速的向目的地传送数据，而目的地主机没有匹配的处理能力，目的地主机可以向出发主机发出该类型的 <code>ICMP</code> 包，提醒出发主机放慢发送速度(请温柔一点吧)。</p>
<ul>
<li>目的地无法到达</li>
</ul>
<p>目的地无法到达(<code>Destination Unreachable</code>)属于错误信息。如果一个路由器接收到一个没办法进一步接力的 <code>IP</code> 包，它会向出发主机发送该类型的 <code>ICMP</code> 包。比如当 <code>IP</code> 包到达最后一个路由器，路由器发现目的地主机 down 机，就会向出发主机发送目的地无法到达(<code>Destination Unreachable</code>)类型的 ICMP 包。目的地无法到达还可能有其他的原因，比如不存在接力路径，比如不被接收的端口号等等。</p>
<ul>
<li>超时</li>
</ul>
<p>超时(<code>Time Exceeded</code>)属于错误信息。<code>IPv4</code> 中的 <code>Time to Live</code>(<code>TTL</code>)和 <code>IPv6</code> 中的 <code>Hop Limit</code> 会随着经过的路由器而递减，当这个区域值减为 <code>0</code> 时，就认为该 <code>IP</code> 包超时(<code>Time Exceeded</code>)。<code>Time Exceeded</code> 就是 <code>TTL</code> 减为 <code>0</code> 时的路由器发给出发主机的 <code>ICMP</code> 包，通知它发生了超时错误。</p>
<p><code>traceroute</code> 就利用了这种类型的 <code>ICMP</code> 包。<code>traceroute</code> 命令用来发现 <code>IP</code> 接力路径(<code>route</code>)上的各个路由器。它向目的地发送 <code>IP</code> 包，第一次的时候，将 <code>TTL</code> 设置为 <code>1</code>，引发第一个路由器的 <code>Time Exceeded</code> 错误。这样，第一个路由器回复 <code>ICMP</code> 包，从而让出发主机知道途径的第一个路由器的信息。随后 TTL 被设置为 2、3、4，…，直到到达目的主机。这样，沿途的每个路由器都会向出发主机发送 <code>ICMP</code> 包来汇报错误。<code>traceroute</code> 将 <code>ICMP</code> 包的信息打印在屏幕上，就是接力路径的信息了。</p>
<ul>
<li>重新定向</li>
</ul>
<p>重新定向(<code>redirect</code>)属于错误信息。当一个路由器收到一个 <code>IP</code> 包，对照其 <code>routing table</code>，发现自己不应该收到该 <code>IP</code> 包，它会向出发主机发送重新定向类型的 <code>ICMP</code>，提醒出发主机修改自己的 <code>routing table</code>。比如下面的网络：</p>
<p><img src="../images/learn-tcp-ip-protocol-53.png" alt="TCP-IP协议森林"></p>
<p>假如 <code>145.1</code> 发送到 <code>145.15</code> 的 <code>IP</code> 包，结果被中间的路由器通过 <code>145.17</code> 的 <code>NIC</code> 收到。那么路由器会发现，根据自己的 <code>routing table</code>，这个 <code>IP</code> 包要原路返回。那么 <code>router</code> 就可以判断出 <code>145.1</code> 的 <code>routing table</code> 可能有问题。所以路由器会向 <code>145.1</code> 发送 <code>redirect</code> 类型的 <code>ICMP</code> 包。</p>
<ul>
<li>IPv6 的 Neighbor Discovery</li>
</ul>
<p><code>ARP</code> 协议用于发现周边的 <code>IP</code> 地址和 <code>MAC</code> 地址的对应。然而，<code>ARP</code> 协议只用于 <code>IPv4</code>，<code>IPv6</code> 并不使用 <code>ARP</code> 协议。<code>IPv6</code> 包通过邻居探索(<code>ND</code>)来实现 <code>ARP</code> 的功能。<code>ND</code> 的工作方式与 <code>ARP</code> 类似，但它基于 <code>ICMP</code> 协议。<code>ICMP</code> 包有 <code>Neighbor Solicitation</code> 和 <code>Neighbor Advertisement</code> 类型。这两个类型分别对应 <code>ARP</code> 协议的询问和回复信息。</p>
<ul>
<li><strong>[3] 总结陈述</strong></li>
</ul>
<p><code>ICMP</code> 协议是 <code>IP</code> 协议的排错帮手，它可以帮助人们及时发现 <code>IP</code> 通信中出现的故障。基于 <code>ICMP</code> 的 <code>ping</code> 和 <code>traceroute</code> 也构成了重要的网络诊断工具。然而，需要注意的是，尽管 <code>ICMP</code> 的设计是出于好的意图，但 <code>ICMP</code> 却经常被黑客借用进行网络攻击，比如利用伪造的 <code>IP</code> 包引发大量的 <code>ICMP</code> 回复，并将这些 <code>ICMP</code> 包导向受害主机，从而形成 <code>DoS</code> 攻击。而 <code>redirect</code> 类型的 <code>ICMP</code> 包可以引起某个主机更改自己的路由表，所以也被用作攻击工具。许多站点选择忽视某些类型的 <code>ICMP</code> 包来提高自身的安全性。</p>
<hr>
<h2 id="4-传输层协议"><a href="#4-传输层协议" class="headerlink" title="4. 传输层协议"></a>4. 传输层协议</h2><h3 id="4-1-傀儡-UDP-协议"><a href="#4-1-傀儡-UDP-协议" class="headerlink" title="4.1 傀儡 (UDP 协议)"></a>4.1 傀儡 (UDP 协议)</h3><p>我们已经讲解了物理层、连接层和网络层。最开始的连接层协议种类繁多(<code>Ethernet</code>、<code>Wifi</code>、<code>ARP</code> 等等)。到了网络层，我们只剩下一个 <code>IP</code> 协议(<code>IPv4</code> 和 <code>IPv6</code> 是替代关系)。进入到传输层(<code>transport layer</code>)，协议的种类又开始繁多起来(比如 <code>TCP</code>、<code>UDP</code>、<code>SCTP</code> 等)。这就好像下面的大树，根部(连接层)分叉很多，然后统一到一个树干(网络层)，到了树冠(传输层)部分又开始开始分叉，而每个树枝上长出更多的树叶(应用层)。我们在网络层已经看到，通过树干的统一，我们实现了一个覆盖全球的互联网络(<code>Internet</code>)。然而，我们可能出于不同的目的利用这张“网”，随之使用的方式也有所区分。不同的传输层协议(以及更多的应用层协议)正是我们使用“网”的不同方式的体现。</p>
<p><img src="../images/learn-tcp-ip-protocol-60.gif" alt="网络分层的“艺术”观点"></p>
<p>传输层最重要的协议为 <code>TCP</code> 协议和 <code>UDP</code> 协议。这两者使用“网”的方式走了两个极端。两个协议的对比非常有趣。<code>TCP</code> 协议复杂，但传输可靠。<code>UDP</code> 协议简单，但传输不可靠。其他的各个传输层协议在某种程度上都是这两个协议的折中。我们先来看传输层协议中比较简单的 <code>UDP</code> 协议。</p>
<ul>
<li><strong>[1] <code>UDP</code> 协议简介</strong></li>
</ul>
<p><code>UDP</code>(<code>User Datagram Protocol</code>)传输与 <code>IP</code> 传输非常类似。你可以将 <code>UDP</code> 协议看作 <code>IP</code> 协议暴露在传输层的一个接口。<code>UDP</code> 协议同样以数据包(<code>datagram</code>)的方式传输，它的传输方式也是”Best Effort”的，所以 <code>UDP</code> 协议也是不可靠的(<code>unreliable</code>)。那么，我们为什么不直接使用 <code>IP</code> 协议而要额外增加一个 <code>UDP</code> 协议呢？</p>
<p>一个重要的原因是 <code>IP</code> 协议中并没有端口(<code>port</code>)的概念。<code>IP</code>协议进行的是 <code>IP</code> 地址到 <code>IP</code> 地址的传输，这意味者两台计算机之间的对话。但每台计算机中需要有多个通信通道，并将多个通信通道分配给不同的进程使用(关于进程，可以参考 <code>Linux</code> 进程基础)。一个端口就代表了这样的一个通信通道。正如我们在邮局和邮差中提到的收信人的概念一样。<code>UDP</code> 协议实现了端口，从而让数据包可以在送到 <code>IP</code> 地址的基础上，进一步可以送到某个端口。</p>
<p><img src="../images/learn-tcp-ip-protocol-61.jpg" alt="UDP：依然不是那么“可靠”"></p>
<p>尽管 <code>UDP</code> 协议非常简单，但它的产生晚于更加复杂的 <code>TCP</code> 协议。早期的网络开发者开发出 <code>IP</code> 协议和 <code>TCP</code> 协议分别位于网络层和传输层，所有的通信都要先经过 <code>TCP</code> 封装，再经过 <code>IP</code> 封装(应用层-&gt;TCP-&gt;IP)。开发者将 <code>TCP/IP</code> 视为相互合作的套装。但很快，网络开发者发现，<code>IP</code> 协议的功能和 <code>TCP</code> 协议的功能是相互独立的。对于一些简单的通信，我们只需要“Best Effort”式的 <code>IP</code> 传输就可以了，而不需要 <code>TCP</code> 协议复杂的建立连接的方式(特别是在早期网络环境中，如果过多的建立 <code>TCP</code> 连接，会造成很大的网络负担，而 <code>UDP</code> 协议可以相对快速的处理这些简单通信)。<code>UDP</code> 协议随之被开发出来，作为 <code>IP</code> 协议在传输层的”傀儡”。这样，网络通信可以通过应用层-&gt;UDP-&gt;IP 的封装方式，绕过 <code>TCP</code> 协议。由于 <code>UDP</code> 协议本身异常简单，实际上只为 <code>IP</code> 传输起到了桥梁的作用。我们将在 <code>TCP</code> 协议的讲解中看到更多 <code>TCP</code> 协议和 <code>UDP</code> 协议的对比。</p>
<p><img src="../images/learn-tcp-ip-protocol-62.jpg" alt="IP和他的傀儡UDP"></p>
<p><code>UDP</code> 的数据包同样分为头部(<code>header</code>)和数据(<code>payload</code>)两部分。<code>UDP</code> 是传输层(<code>transport layer</code>)协议，这意味着 <code>UDP</code> 的数据包需要经过 <code>IP</code> 协议的封装(<code>encapsulation</code>)，然后通过 <code>IP</code> 协议传输到目的电脑。随后 <code>UDP</code> 包在目的电脑拆封，并将信息送到相应端口的缓存中。</p>
<ul>
<li><strong>[2] <code>UDP</code> 协议的头部</strong></li>
</ul>
<p>下面的 <code>source port</code> 和 <code>destination port</code> 分别为 <code>UDP</code> 包的出发端口和目的地端口。<code>Length</code> 为整个 <code>UDP</code> 包的长度。</p>
<p><img src="../images/learn-tcp-ip-protocol-63.png" alt="UDP协议的头部"></p>
<p><code>checksum</code> 的算法与 <code>IP</code> 协议的 <code>header checksum</code> 算法相类似。然而，<code>UDP</code> 的 <code>checksum</code> 所校验的序列包括了整个 <code>UDP</code> 数据包，以及封装的 <code>IP</code> 头部的一些信息(主要为出发地 <code>IP</code> 和目的地 IP)。这样，<code>checksum</code> 就可以校验 <code>IP:端口</code> 的正确性了。在 <code>IPv4</code> 中，<code>checksum</code> 可以为 <code>0</code>，意味着不使用 <code>checksum</code>。<code>IPv6</code> 要求必须进行 <code>checksum</code> 校验。</p>
<ul>
<li><strong>[3] 端口与 socket</strong></li>
</ul>
<p>端口(<code>port</code>)是伴随着传输层诞生的概念。它可以将网络层的 <code>IP</code> 通信分送到各个通信通道。<code>UDP</code> 协议和 <code>TCP</code> 协议尽管在工作方式上有很大的不同，但它们都建立了从一个端口到另一个端口的通信。</p>
<p><img src="../images/learn-tcp-ip-protocol-64.jpg" alt="IP：端口"></p>
<p>随着我们进入传输层，我们也可以调用操作系统中的 <code>API</code>，来构建 <code>socket</code>。<code>Socket</code> 是操作系统提供的一个编程接口，它用来代表某个网络通信。应用程序通过 <code>socket</code> 来调用系统内核中处理网络协议的模块，而这些内核模块会负责具体的网络协议的实施。这样，我们可以让内核来接收网络协议的细节，而我们只需要提供所要传输的内容就可以了，内核会帮我们控制格式，并进一步向底层封装。因此，在实际应用中，我们并不需要知道具体怎么构成一个 <code>UDP</code> 包，而只需要提供相关信息(比如 <code>IP</code> 地址，比如端口号，比如所要传输的信息)，操作系统内核会在传输之前会根据我们提供的相关信息构成一个合格的 <code>UDP</code> 包(以及下层的包和帧)。<code>socket</code> 是一个比较大的课题，在协议森林系列中不会过多深入。</p>
<ul>
<li><strong>[4] 总结陈述</strong></li>
</ul>
<p>端口是传输层带来的最重要的概念。我们进一步了解了 <code>UDP</code> 协议。如果已经掌握了 <code>IP</code> 协议，那么 <code>UDP</code> 协议就没有任何困难可言，它只是 <code>IP</code> 协议暴露在传输层上的接口。</p>
<hr>
<h3 id="4-2-不放弃-TCP-协议与”流”通信"><a href="#4-2-不放弃-TCP-协议与”流”通信" class="headerlink" title="4.2 不放弃 (TCP 协议与”流”通信)"></a>4.2 不放弃 (TCP 协议与”流”通信)</h3><p><code>TCP</code>(<code>Transportation Control Protocol</code>)协议与 <code>IP</code> 协议是一同产生的。事实上，两者最初是一个协议，后来才被分拆成网络层的 <code>IP</code> 和传输层的 TCP。我们已经在 <code>UDP</code> 协议中介绍过，<code>UDP</code> 协议是 <code>IP</code> 协议在传输层的“傀儡”，用来实现数据包形式的通信。而 <code>TCP</code> 协议则实现了“流”形式的通信。</p>
<ul>
<li><strong>[1] “流”通信</strong></li>
</ul>
<p><code>TCP</code> 协议是传输层协议，实现的是端口到端口(<code>port</code>)的通信。更进一步，<code>TCP</code> 协议虚拟了文本流(<code>byte stream</code>)的通信。在 <code>Linux</code> 文本流中我们谈到，计算机数据的本质是有序的 <code>0/1</code> 序列(如果以 <code>byte</code> 为单位，就叫做文本流)。计算机的功能就是储存和处理文本流。<code>CPU + memory + 存储设备</code> 实现了文本流在同一台计算机内部的加工处理。通过一些 <code>IO</code>，比如屏幕和键盘，文本流实现了人机交互。而进一步，如果网络通信可在不同计算机之间进行文本流的交互，那么我们就和整个计算机系统的数据处理方式实现了对接。</p>
<p><code>IP</code> 协议和 <code>UDP</code> 协议采用的是数据包的方式传送，后发出的数据包可能早到，我们并不能保证数据到达的次序。<code>TCP</code> 协议确保了数据到达的顺序与文本流顺序相符。当计算机从 <code>TCP</code> 协议的接口读取数据时，这些数据已经是排列好顺序的“流”了。比如我们有一个大文件要从本地主机发送到远程主机，如果是按照“流”接收到的话，我们可以一边接收，一边将文本流存入文件系统。这样，等到“流”接收完了，硬盘写入操作也已经完成。如果采取 <code>UDP</code> 的传输方式，我们需要等到所有的数据到达后，进行排序，才能组装成大的文件。这种情况下，我们不得不使用大量的计算机资源来存储已经到达的数据，直到所有数据都达到了，才能开始处理。</p>
<p>“流”的要点是次序(<code>order</code>)，然而实现这一点并不简单。<code>TCP</code> 协议是基于 <code>IP</code> 协议的，所以最终数据传送还是以 <code>IP</code> 数据包为单位进行的。如果一个文本流很长的话，我们不可能将整个文本流放入到一个 <code>IP</code> 数据包中，那样有可能会超过 MTU。所以，<code>TCP</code> 协议封装到 <code>IP</code> 包的不是整个文本流，而是 <code>TCP</code> 协议所规定的片段(<code>segment</code>)。与之前的一个 <code>IP</code> 或者 <code>UDP</code> 数据包类似，一个 <code>TCP</code> 片段同样分为头部(<code>header</code>)和数据(<code>payload</code>)两部分<code>(“片段”这个名字更多是起提醒作用：嘿，这里并不是完整的文本流)</code>。整个文本流按照次序被分成小段，而每一段被放入 <code>TCP</code> 片段的数据部分。一个 <code>TCP</code> 片段封装成的 <code>IP</code> 包不超过整个 <code>IP</code> 接力路径上的最小 <code>MTU</code>，从而避免令人痛苦的碎片化(<code>fragmentation</code>)。</p>
<p>给文本流分段是在发送主机完成的，而碎片化是在网络中的路由器完成的。路由器要处理许多路的通信，所以相当繁忙。文本流提前在发送主机分好段，可以避免在路由器上执行碎片化，可大大减小网络负担。</p>
<p><img src="../images/learn-tcp-ip-protocol-70.jpg" alt="片段与编号"></p>
<p><code>TCP</code> 片段的头部(<code>header</code>)会存有该片段的序列号(<code>sequence number</code>)。这样，接收的计算机就可以知道接收到的片段在原文本流中的顺序了，也可以知道自己下一步需要接收哪个片段以形成流。比如已经接收到了片段 <code>1</code>，片段 <code>2</code>，片段 <code>3</code>，那么接收主机就开始期待片段 <code>4</code>。如果接收到不符合顺序的数据包(比如片段 8)，接收方的 <code>TCP</code> 模块可以拒绝接收，从而保证呈现给接收主机的信息是符合次序的“流”。</p>
<ul>
<li><strong>[2] 可靠性</strong></li>
</ul>
<p>片段编号这个初步的想法并不能解决我们所有的问题。<code>IP</code> 协议是不可靠的，所以 <code>IP</code> 数据包可能在传输过程中发生错误或者丢失。而 <code>IP</code> 传输是”Best Effort”式的，如果发生异常情况，我们的 <code>IP</code> 数据包就会被轻易的丢弃掉。另一方面，如果乱序(<code>out of order</code>)片段到达，根据我们上面说的，接收主机不会接收。这样，错误片段、丢失片段和被拒片段的联手破坏之下，接收主机只可能收到一个充满“漏洞”的文本流。</p>
<p><img src="../images/learn-tcp-ip-protocol-71.jpg" alt="请补上漏洞"></p>
<p><code>TCP</code> 的补救方法是，在每收到一个正确的、符合次序的片段之后，就向发送方<code>(也就是连接的另一段)</code>发送一个特殊的 <code>TCP</code> 片段，用来知会(<code>ACK，acknowledge</code>)发送方：我已经收到那个片段了。这个特殊的 <code>TCP</code> 片段叫做 <code>ACK</code> 回复。如果一个片段序号为 L，对应 <code>ACK</code> 回复有回复号 <code>L+1</code>，也就是接收方期待接收的下一个发送片段的序号。如果发送方在一定时间等待之后，还是没有收到 <code>ACK</code> 回复，那么它推断之前发送的片段一定发生了异常。发送方会重复发送(<code>retransmit</code>)那个出现异常的片段，等待 <code>ACK</code> 回复，如果还没有收到，那么再重复发送原片段…<br>直到收到该片段对应的 <code>ACK</code> 回复(回复号为 L+1 的 ACK)。</p>
<p><img src="../images/learn-tcp-ip-protocol-72.png" alt="终于收到ACK的发送主机，泪流满面"></p>
<p>当发送方收到 <code>ACK</code> 回复时，它看到里面的回复号为 <code>L+1</code>，也就是发送方下一个应该发送的 <code>TCP</code> 片段序号。发送方推断出之前的片段已经被正确的接收，随后发出 <code>L+1</code> 号片段。ACK 回复也有可能丢失。对于发送方来说，这和接收方拒绝发送 <code>ACK</code> 回复是一样的。发送方会重复发送，而接收方接收到已知会过的片段，推断出 <code>ACK</code> 回复丢失，会重新发送 <code>ACK</code> 回复。</p>
<p>通过 <code>ACK</code> 回复和重新发送机制，<code>TCP</code> 协议将片段传输变得可靠。尽管底盘是不可靠的 <code>IP</code> 协议，但 <code>TCP</code> 协议以一种“不放弃的精神”，不断尝试，最终成功。(技术也可以很励志)</p>
<p><img src="../images/learn-tcp-ip-protocol-73.jpg" alt="面对“挫折”，TCP协议的态度: never give up"></p>
<p><code>TCP</code> 协议和 <code>UDP</code> 协议走了两个极端。<code>TCP</code> 协议复杂但可靠，<code>UDP</code> 协议轻便但不可靠。在处理异常的时候，<code>TCP</code> 极端负责，而 <code>UDP</code> 一副无所谓的样子。我们可以顺便“黑”一下 <code>UDP</code> 协议：</p>
<p><img src="../images/learn-tcp-ip-protocol-74.jpg" alt="同样面对“挫折”，UDP的态度: who cares..."></p>
<ul>
<li><strong>[3] 滑窗</strong></li>
</ul>
<p>上面的工作方式中，发送方保持发送-&gt;等待 ACK-&gt;发送-&gt;等待 ACK…的单线工作方式，这样的工作方式叫做 <code>stop-and-wait</code>。<code>stop-and-wait</code> 虽然实现了 <code>TCP</code> 通信的可靠性，但同时牺牲了网络通信的效率。在等待 <code>ACK</code> 的时间段内，我们的网络都处于闲置<code>(idle)</code>状态。我们希望有一种方式，可以同时发送出多个片段。然而如果同时发出多个片段，那么由于 <code>IP</code> 包传送是无次序的，有可能会生成乱序片段<code>(out-of-order)</code>，也就是后发出的片段先到达。在 <code>stop-and-wait</code> 的工作方式下，乱序片段完全被拒绝，这也很不效率。毕竟，乱序片段只是提前到达的片段。我们可以在缓存中先存放它，等到它之前的片段补充完毕，再将它缀在后面。然而，如果一个乱序片段实在是太过提前<code>(太“乱”了)</code>，该片段将长时间占用缓存。我们需要一种折中的方法来解决该问题：利用缓存保留一些“不那么乱”的片段，期望能在段时间内补充上之前的片段<code>(暂不处理，但发送相应的ACK)</code>；对于“乱”的比较厉害的片段，则将它们拒绝(不处理，也不发送对应的 ACK)。</p>
<p><img src="../images/learn-tcp-ip-protocol-75.jpg" alt="总有那么几个“出格”片段"></p>
<p>滑窗(<code>sliding window</code>)被同时应用于接收方和发送方，以解决以上问题。发送方和接收方各有一个滑窗。当片段位于滑窗中时，表示 <code>TCP</code> 正在处理该片段。滑窗中可以有多个片段，也就是可以同时处理多个片段。滑窗越大，越大的滑窗同时处理的片段数目越多<code>(当然，计算机也必须分配出更多的缓存供滑窗使用)</code>。</p>
<p><img src="../images/learn-tcp-ip-protocol-76.jpg" alt="同时处理多个片段"></p>
<p>我们假设一个可以容纳三个片段的滑窗，并假设片段从左向右排列。对于发送方来说，滑窗的左侧为已发送并已 <code>ACK</code> 过的片段序列，滑窗右侧是尚未发送的片段序列。滑窗中的片段(比如片段 5，6，7)被发送出去，并等待相应的 <code>ACK</code>。如果收到片段 <code>5</code> 的 <code>ACK</code>，滑窗将向右移动。这样，新的片段从右侧进入滑窗内，被发送出去，并进入等待状态。在接收到片段 5 的 <code>ACK</code> 之前，滑窗不会移动，即使已经收到了片段 <code>6</code> 和 <code>7</code> 的 <code>ACK</code>。这样，就保证了滑窗左侧的序列是已经发送的、接收到 <code>ACK</code> 的、符合顺序的片段序列。</p>
<p>对于接收方来说，滑窗的左侧是已经正确收到并 <code>ACK</code> 回复过的片段(比如片段 1，2，3，4)，也就是正确接收到的文本流。滑窗中是期望接收的片段(比如片段 5, 6, 7)。同样，如果片段 <code>6</code>，<code>7</code> 先到达，那么滑窗不会移动。如果片段 <code>5</code> 先到达，那么滑窗会向右移动，以等待接收新的片段。如果出现滑窗之外的片段，比如片段 <code>9</code>，那么滑窗将拒绝接收。</p>
<p>下面一个视频中，我尝试模拟可容纳三个片段的滑窗(固定大小)的工作过程。</p>
<p>如果视频加载有问题，可点下面链接： <code>http://v.youku.com/v_show/id_XNDg1NDUyMDUy.html</code>。</p>
<p>上面的视频是用 <code>Python</code> 和 <code>matplotlib</code> 包制作的。蓝色点表示片段，红色点表示 <code>ACK</code>。为了说明乱序片段，我故意让片段和 <code>ACK</code> 的速度从两个值中随机选择。可以看到，随着滑窗的滑动，越来越多的片段被正确的传送。利用滑窗，我们一定程度上实现了对乱序数据的缓存。但是，过于乱序的数据依然会被拒绝。我们之前说的 <code>stop-and-wait</code> 的工作方式，相当于发送方和接收方的滑窗都只能容纳一个片段。</p>
<p>我们将在以后看到，<code>TCP</code> 协议有实时调整滑窗大小的算法，以实现最优效率。</p>
<ul>
<li><strong>[4] 总结陈述</strong></li>
</ul>
<p><code>TCP</code> 协议和 <code>UDP</code> 协议走了两个极端。<code>TCP</code> 协议复杂但可靠，<code>UDP</code> 协议轻便但不可靠。在处理异常的时候，<code>TCP</code> 极端负责，而 <code>UDP</code> 一副无所谓的样子。在 <code>TCP</code> 中，分段和编号实现了次序；<code>ACK</code> 和重新发送实现了可靠性；<code>sliding window</code> 则让上面的机制更加有效率的运行。<code>Never give up</code>，这就是 <code>TCP</code> 协议的态度。</p>
<hr>
<h3 id="4-3-爱的传声筒-TCP-连接"><a href="#4-3-爱的传声筒-TCP-连接" class="headerlink" title="4.3 爱的传声筒 (TCP 连接)"></a>4.3 爱的传声筒 (TCP 连接)</h3><p>在 <code>TCP</code> 协议与”流”通信中，我们概念性的讲解了 <code>TCP</code> 通信的方式。可以看到，<code>TCP</code> 通信最重要的特征是：有序(<code>ordering</code>)和可靠(<code>reliable</code>)。有序是通过将文本流分段并编号实现的。可靠是通过 <code>ACK</code> 回复和重复发送(<code>retransmission</code>)实现的。这一篇文章将引入 <code>TCP</code> 连接(<code>connection</code>)的概念。</p>
<ul>
<li><strong>[1] TCP 连接</strong></li>
</ul>
<p>网络层在逻辑上提供了端口的概念。一个 <code>IP</code> 地址可以有多个端口。一个具体的端口需要 <code>IP</code> 地址和端口号共同确定(我们记为 <code>IP:port</code> 的形式)。一个连接为两个 <code>IP:port</code> 之间建立 <code>TCP</code> 通信。(一个常用的比喻为：<code>TCP</code> 连接就像两个人打电话，<code>IP</code> 为总机号码，<code>port</code> 为分机号码)</p>
<p><img src="../images/learn-tcp-ip-protocol-80.gif" alt="TCP连接就像两个人打电话"></p>
<p>参与连接的如果是两台电脑，那么两台电脑操作系统的 <code>TCP</code> 模块负责建立连接。每个连接有四个参数(两个 <code>IP</code>，两个端口)，来表明“谁在和谁通话”。每台电脑都会记录有这四个参数，以确定是哪一个连接。如果这四个参数完全相同，则为同一连接；如果这四个参数有一个不同，即为不同的连接。这意味着，同一个端口上可以有多个连接。内核中的 <code>TCP</code> 模块生成连接之后，将连接分配给进程使用。</p>
<p><img src="../images/learn-tcp-ip-protocol-81.jpg" alt="一个端口上可以有多个连接"></p>
<p><code>TCP</code> 连接是双工(<code>duplex</code>)的。在 <code>TCP</code> 协议与”流”通信中，我们所展示的 <code>TCP</code> 传输是单向的。双向连接实际上就是建立两个方向的 <code>TCP</code> 传输，所以概念上并不复杂。这时，连接的每一方都需要两个滑窗，以分别处理发送的文本流和接收的文本流。由于连接的双向性，我们也要为两个方向的文本流编号。这两个文本流的编号相互独立。为文本流分段和编号由发送方来处理，回复 <code>ACK</code> 则由接收的一方进行。</p>
<ul>
<li><strong>[2] TCP 片段的头部格式</strong></li>
</ul>
<p>在深入 <code>TCP</code> 连接之前，我们需要对 <code>TCP</code> 片段的头部格式有一些了解。我们知道，<code>TCP</code> 片段分为头部和数据。数据部分为 <code>TCP</code> 真正传输的文本流数据。下面为 <code>TCP</code> 片段的头部格式：</p>
<p><img src="../images/learn-tcp-ip-protocol-82.png" alt="来自 wikipedia"></p>
<p>先关注下面几点：</p>
<ol>
<li>一个 <code>TCP</code> 头部需要包含出发端口(<code>source port</code>)和目的地端口(<code>destination port</code>)。这些与 <code>IP</code> 头中的两个 <code>IP</code> 地址共同确定了连接。</li>
<li>每个 <code>TCP</code> 片段都有序列号(<code>sequence number</code>)。这些序列号最终将数据部分的文本片段整理成为文本流。</li>
<li><code>ACK</code> 是一位(<code>bit</code>)。只有 <code>ACK</code> 位设定的时候，回复号(<code>Acknowledgement number</code>)才有效。<code>ACK</code> 回复号说明了接收方期待接收的下一个片段，所以 <code>ACK</code> 回复号为最后接收到的片段序号加 <code>1</code>。</li>
</ol>
<p>很多时候，<code>ACK</code> 回复“附着”在发送的数据片段中。<code>TCP</code> 协议是双向的。比如 <code>A</code> 和 <code>B</code> 两个电脑。<code>ACK</code> 回复是接收方回复给发送方(比如 <code>A</code> 发送给 <code>B</code>，<code>B</code> 回复 <code>A</code>)。但同时，<code>B</code> 也可以是发送方，<code>B</code> 有可能有数据发送给 <code>A</code>，所以 <code>B</code> 就把 <code>ACK</code> 回复附着在它要发送给 <code>A</code> 的数据片段的头部。这样可以减少 <code>ACK</code> 所占用的交通流量。一个片段可以只包含 <code>ACK</code> 回复。一个纯粹的 <code>ACK</code> 回复片段不传送文本流，所以不消耗序列号。如果有下一个正常的数据片段，它的序号将与纯粹 <code>ACK</code> 回复片段的序号相同。(<code>ACK</code> 回复还可以“附着”在 <code>SYN</code> 片段和 <code>FIN</code> 片段)</p>
<ol start="4">
<li><code>ACK</code> 后面还有 <code>SYN</code> 和 <code>FIN</code>，它们也各占据一位(<code>bit</code>)。我将在后面说明这两位。</li>
</ol>
<ul>
<li><strong>[3] 连接的建立</strong></li>
</ul>
<p>在 <code>TCP</code> 协议与”流”通信中讨论的 <code>TCP</code> 传输需要一个前提：<code>TCP</code> 连接已经建立。然而，<code>TCP</code> 连接从无到有需要一个建立连接的过程。建立连接的最重要目是让连接的双方交换初始序列号(<code>ISN</code>)。根据 <code>TCP</code> 协议的规定，文本流的第一个片段的序列号不能是确定的数字(比如说 <code>1</code>)。连接的双方各自随机生成自己的 <code>ISN</code>，然后再利用的一定方式让对方了解。这样的规定是出于 <code>TCP</code> 连接安全考虑：如果以一个确定的数字作为初始的 <code>TCP</code> 序号，那么其他人很容易猜出接下来的序列号，并按照正确的序号发送“伪装”的 <code>TCP</code> 片段，以插入到文本流中。</p>
<p><code>ISN</code> 交换是通过 <code>SYN</code> 片段实现的。<code>SYN</code> 片段由头部的 <code>SYN</code> 位表明，它的序列号为发送方的 <code>ISN</code>。该片段由连接的一方首先发给给另一方，我们将发送 <code>SYN</code> 的一方称为客户(<code>client</code>)，而接收 SYN 的一方称为服务器(<code>server</code>)。我们使用 <code>ISN</code>(c)表示 <code>client</code> 一方的 <code>ISN</code>，使用 <code>ISN</code>(s)表示 <code>server</code> 一方的 <code>ISN</code>。随后，接收到 <code>SYN</code> 的 <code>server</code> 需要回复 <code>ACK</code>，并发送出包含有 <code>server</code> 的 <code>ISN</code> 的 <code>SYN</code> 片段。下图为建立连接的过程，也就是经典的 <code>TCP</code> 三次握手(<code>three-way handshaking</code>)。两条竖直线分别为 <code>client</code> 和 <code>server</code> 的时间轴。每个箭头代表了一次 <code>TCP</code> 片段的单向传输。</p>
<p><img src="../images/learn-tcp-ip-protocol-83.png" alt="连接的建立"></p>
<p>青色为纯粹的 <code>ACK</code> 片段。整个过程的本质是双方互发含有自己的 <code>ISN</code> 的 <code>SYN</code> 片段。根据 <code>TCP</code> 传输的规则，接收到 <code>ISN</code> 的一方需要回复 <code>ACK</code>，所以共计四片信息在建立连接过程中传输。之所以是三次握手(而不是四次)，是因为 <code>server</code> 将发送 <code>SYN</code> 和回复 <code>ACK</code> 合并到一个 <code>TCP</code> 片段中。我们以 <code>client</code> 方为例。<code>client</code> 知道自己的 <code>ISN</code>(也就是 <code>ISN</code>(c))。建立连接之后，它也知道了对方的 <code>ISN</code>(s)。此后，如果需要发送文本流片段，则编号为 <code>ISN(c) + 1</code>, <code>ISN(c) + 2</code> …。如果接收文本流片段，则期待接收 <code>ISN(s) + 1</code>, <code>ISN(s) + 2</code> …。</p>
<p>连接建立之后，连接的双方就可以按照 <code>TCP</code> 传输的方式相互发送文本流了。</p>
<ul>
<li><strong>[4] 连接的正常终结</strong></li>
</ul>
<p>一个连接建立之后，连接两端的进程可以利用该连接进行通信。当连接的一方觉得“我讲完了”，它可以终结连接中发送到对方方向的通信。连接最终通过、四次握(<code>four-wayhandshaking</code>)的方式终结，连接终结使用的是特殊片段 <code>FIN</code>(FIN 位为 1 的片段)。</p>
<p><img src="../images/learn-tcp-ip-protocol-84.png" alt="连接的正常终结"></p>
<p>我们可以看到，连接终结的过程中，连接双方也交换了四片信息(两个 <code>FIN</code> 和两个 <code>ACK</code>)。在终结连接的过程中，<code>TCP</code> 并没有合并 <code>FIN</code> 与 <code>ACK</code> 片段。原因是 <code>TCP</code> 连接允许单向关闭(<code>half-close</code>)。也就是说，<code>TCP</code> 连接关闭了一个方向的传输，成为一个单向连接(<code>half-duplex</code>)。第二个箭头和第三个箭头传递必须分开，才能有空隙在开放的方向上继续传输。如果第二个箭头和第三个箭头合并在一起，那么，随着一方关闭，另一方也要被迫关闭。</p>
<p>第二和第三次握手之间，<code>server</code> 可以继续单向的发送片段给 <code>client</code>，但 <code>client</code> 不能发送数据片段给 <code>server</code>。</p>
<p>(上面的终结从 <code>client</code> 先发起，<code>TCP</code> 连接终结也可以从 <code>server</code> 先发起。)</p>
<p>在 <code>Client</code> 发送出最后的 <code>ACK</code> 回复，但该 <code>ACK</code> 可能丢失。<code>Server</code> 如果没有收到 <code>ACK</code>，将不断重复发送 <code>FIN</code> 片段。所以 <code>Client</code> 不能立即关闭，它必须确认 <code>Server</code> 接收到了该 <code>ACK</code>。<code>Client</code> 会在发送出 <code>ACK</code> 之后进入到 <code>TIME_WAIT</code> 状态。<code>Client</code> 会设置一个计时器，等待 <code>2MSL</code> 的时间。如果在该时间内再次收到 <code>FIN</code>，那么 <code>Client</code> 会重发 <code>ACK</code> 并再次等待 <code>2MSL</code>。所谓的 <code>2MSL</code> 是两倍的 <code>MSL</code>(<code>Maximum Segment Lifetime</code>)。<code>MSL</code> 指一个片段在网络中最大的存活时间，<code>2MSL</code> 就是一个发送和一个回复所需的最大时间。如果直到 <code>2MSL</code>，<code>Client</code> 都没有再次收到 <code>FIN</code>，那么 <code>Client</code> 推断 <code>ACK</code> 已经被成功接收，则结束 <code>TCP</code> 连接。</p>
<p><img src="../images/learn-tcp-ip-protocol-85.gif" alt="TIME_WAIT State"></p>
<ul>
<li><strong>[5] 总结陈述</strong></li>
</ul>
<p><code>TCP</code> 是连接导向的协议，与之对应的是像 <code>UDP</code> 这样的非连接导向的协议。连接能带来更好的传输控制，但也需要更多额外的工作，比如连接的建立和终结。我们还初步了解了 <code>TCP</code> 的头部格式。应该注意到，许多时候我们将 <code>ACK</code> 片段“附着”在其他片段上。相对于纯粹的 <code>ACK</code> 片段，我们这样做节约了 <code>ACK</code> 所需的流量。事实上，由于 <code>ACK</code> 片段所需的 <code>ACK</code> 位和 <code>acknowledge number</code> 区域总是存在于 <code>TCP</code> 的头部，所以附着 <code>ACK</code> 片段的成本基本上等于 <code>0</code>。</p>
<hr>
<h3 id="4-4-魔鬼细节-TCP-滑窗管理"><a href="#4-4-魔鬼细节-TCP-滑窗管理" class="headerlink" title="4.4 魔鬼细节 (TCP 滑窗管理)"></a>4.4 魔鬼细节 (TCP 滑窗管理)</h3><p>在 <code>TCP</code> 协议与”流”通信中，我们建立了滑窗(<code>sliding window</code>)的基本概念。通过滑窗与 <code>ACK</code> 的配合，我们一方面实现了 <code>TCP</code> 传输的可靠性，另一方面也一定程度上提高了效率。然而，之前的解释只是概念性的。<code>TCP</code> 为了达到更好的传输效率，对上面的工作方式进行了许多改进。我们需要深入到细节，才能看清楚 <code>TCP</code> 协议的智慧所在。</p>
<ul>
<li><strong>[1] 累计 ACK</strong></li>
</ul>
<p>在 <code>TCP</code> 连接中，我们通过将 <code>ACK</code> 回复“附着”在其他数据片段的方式，减少了 <code>ACK</code> 回复所消耗的流量。但这并不是全部的故事。<code>TCP</code> 协议并不是对每个片段都发送 <code>ACK</code> 回复。<code>TCP</code> 协议实际采用的是累计 <code>ACK</code> 回复(<code>accumulative acknowledgement</code>)。接收方往往利用一个 <code>ACK</code> 回复来知会连续多个片段的成功接收。通过累计 <code>ACK</code>，所需要的 <code>ACK</code> 回复通常可以降到 <code>50%</code>。如下图所示，橙色为已经接收的片段。方框为滑窗，滑窗可容纳 <code>3</code> 个片段。</p>
<p><img src="../images/learn-tcp-ip-protocol-90.png" alt="累计ACK"></p>
<p>滑窗还没接收到片段 <code>7</code> 时，已接收到片段 <code>8</code>，<code>9</code>。这样就在滑窗中制造了一个“空穴”(<code>hole</code>)。当滑窗最终接收到片段 <code>7</code> 时，滑窗送出一个回复号为 <code>10</code> 的 <code>ACK</code> 回复。发送方收到该回复，会意识到，片段 <code>10</code> 之前的片段已经按照次序被成功接收。整个过程中节约了片段 <code>7</code> 和片段 <code>8</code> 所需的两个 <code>ACK</code> 回复。此外，接收方在接收到片断，并应该回复 <code>ACK</code> 的时候，会故意延迟一些时间。如果在延迟的时间里，有后续的片段到达，就可以利用累计 <code>ACK</code> 来一起回复了。</p>
<ul>
<li><strong>[2] 滑窗结构</strong></li>
</ul>
<p>在之前的讨论中，我们以片段为单位，来衡量滑窗的大小的。真实的滑窗是以 <code>byte</code> 为单位表示大小，但这并不会对我们之前的讨论造成太大的影响。发送方滑窗可以分为下面两个部分。<code>offered window</code> 为整个滑窗的大小。</p>
<p><img src="../images/learn-tcp-ip-protocol-91.png" alt="滑窗结构"></p>
<p>接收方滑窗可分为三个部分：</p>
<p><img src="../images/learn-tcp-ip-protocol-92.png" alt="滑窗结构"></p>
<p>可以看到，接收方的滑窗相对于发送方的滑窗多了一个 <code>Received; ACKed; Not Sent to Proc</code> 的部分。接收方接收到的文本流必须等待进程来读取。如果进程正忙于做别的事情，那么这些文本流即使已经正确接收，还是需要暂时占用接收缓存。当出现上述占用时，滑窗的可用部分(也就是图中 <code>advertised window</code>)就会缩水。这意味着接收方的处理能力下降。如果这个时候发送方依然按照之前的速率发送数据给接收方，接收方将无力接收这些数据。</p>
<ul>
<li><strong>[3] 流量控制</strong></li>
</ul>
<p><code>TCP</code> 协议会根据情况自动改变滑窗大小，以实现流量控制。流量控制(<code>flow control</code>)是指接收方将 <code>advertised window</code> 的大小通知给发送方，从而指导发送方修改 <code>offered window</code> 的大小。接收方将该信息放在 <code>TCP</code> 头部的 <code>window size</code> 区域：</p>
<p><img src="../images/learn-tcp-ip-protocol-93.png" alt="流量控制"></p>
<p>发送方在收到 <code>window size</code> 的通知时，会调整自己滑窗的大小，让 <code>offered window</code> 和 <code>advertised window</code> 相符。这样，发送窗口变小，文本流发送速率降低，从而减少了接收方的负担。</p>
<ul>
<li><strong>[4] 零窗口</strong></li>
</ul>
<p><code>advertised window</code> 大小有可能变为 <code>0</code>，这意味着接收方的接收能力降为 <code>0</code>。发送方收到大小为 <code>0</code> 的 <code>advertised window</code> 通知时，停止发送。当接收方经过处理，再次产生可用的 <code>advertised window</code> 时，接收方会通过纯粹的 <code>ACK</code> 回复来通知发送方，让发送方恢复发送。然而，<code>ACK</code> 回复的传送并不是可靠的。如果该 <code>ACK</code> 回复丢失，那么 <code>TCP</code> 传输将陷入死锁(<code>deadlock</code>)状态。</p>
<p>为此，发送方会在零窗口后，不断探测接收方的窗口。窗口探测(<code>window probe</code>)时，发送方会向接收方发送包含 <code>1 byte</code> 文本流的 <code>TCP</code> 片段，并等待 <code>ACK</code> 回复(该 <code>ACK</code> 回复包含有 <code>window size</code>)。由于有 <code>1 byte</code> 的数据存在，所以该传输是可靠的，而不用担心 <code>ACK</code> 回复丢失的问题。如果探测结果显示窗口依然为 <code>0</code>，发送方会等待更长的时间，然后再次进行窗口探测，直到 <code>TCP</code> 传输恢复。</p>
<ul>
<li><strong>[5] 白痴窗口综合症</strong></li>
</ul>
<p>滑窗机制有可能犯病，比如白痴窗口综合症(<code>Silly Window Syndrome</code>)。假设这样一种情形：接收方宣布(<code>advertise</code>)一个小的窗口，发送方根据 <code>advertised window</code>，发送一个小的片段。接收方的小窗口被填满，经过处理，接收方再宣布一个小的窗口。这就是“白痴窗口综合症”：<code>TCP</code> 通信的片段中包含的数据量很小。在这样的情况下，<code>TCP</code> 通信的片段所含的信息都很小，网络流量主要是 <code>TCP</code> 片段的头部，从而造成流量的浪费(由于 <code>TCP</code> 头部很大，我们希望每个 <code>TCP</code> 片段中含有比较多的数据)。</p>
<p>如果发送方不断发送小的片段，也会造成“白痴窗口”。为了解决这个问题，需要从两方面入手。<code>TCP</code> 中有相关的规定，要求：接收方宣告的窗口必须达到一定的尺寸，否则等待。除了一些特殊情况，发送方发送的片段必须达到一定的尺寸，否则等待。特殊情况主要是指需要最小化延迟的 <code>TCP</code> 应用(比如命令行互动)。</p>
<ul>
<li><strong>[6] 总结陈述</strong></li>
</ul>
<p>累计 <code>ACK</code> 减少了 <code>TCP</code> 传输过程中所需的 ACK 流量。通过流量管理，<code>TCP</code> 连接两端的工作能力可以匹配，从而减少不不要的传输浪费。累计 <code>ACK</code> 和流量控制都是 <code>TCP</code> 协议的重要特征。<code>TCP</code> 协议相当复杂，并充斥着各种细节。然而 <code>TCP</code> 协议又是如此重要的一个协议，引领风骚三十年，可以说是互联网的奇迹。这些细节正是 <code>TCP</code> 协议成功的原因，并值得我们深入了解。</p>
<hr>
<h3 id="4-5-涅槃-TCP-重新发送"><a href="#4-5-涅槃-TCP-重新发送" class="headerlink" title="4.5 涅槃 (TCP 重新发送)"></a>4.5 涅槃 (TCP 重新发送)</h3><p><code>TCP</code> 协议是一个可靠的协议。它通过重新发送(<code>retransmission</code>)来实现 <code>TCP</code> 片段传输的可靠性。简单的说，<code>TCP</code> 会不断重复发送 <code>TCP</code> 片段，直到片段被正确接收。</p>
<ul>
<li><strong>[1] TCP 片段丢失</strong></li>
</ul>
<p><img src="../images/learn-tcp-ip-protocol-94.png" alt="TCP头部的checksum"></p>
<p>接收方(<code>receiver</code>)可以通过校验 <code>TCP</code> 片段头部中 <code>checksum</code> 区域来检验 <code>TCP</code> 片段是否出错。我们已经接触过了 <code>IP</code> 协议详解的 <code>checksum</code> 算法。<code>TCP</code> 片段的 <code>checksum</code> 算法与之类似。<code>IP</code> 协议的 <code>checksum</code> 只校验头部，<code>TCP</code> 片段头部的 <code>checksum</code> 会校验包括 <code>IP</code> 头部、<code>TCP</code> 头部和 <code>TCP</code> 数据在内的整个序列，确保 <code>IP</code> 地址、端口号和其他相关信息正确。如果 <code>TCP</code> 片段出错，接收方可以简单的丢弃改 <code>TCP</code> 片段，也就相当于 <code>TCP</code> 片段丢失。</p>
<p><code>TCP</code> 片段包裹在一个 <code>IP</code> 包中传输。<code>IP</code> 包可能在网络中丢失。导致 <code>IP</code> 包丢失的原因可能有很多，比如 <code>IP</code> 包经过太多的路由器接力，达到 <code>hop limit</code>；比如路由器太过拥挤，导致一些 <code>IP</code> 包被丢弃；再比如路由表(<code>routing table</code>)没有及时更新，导致 <code>IP</code> 包无法送达目的地。下面我们要介绍两种重新发送 <code>TCP</code> 片段的机制：<strong>超时重新发送</strong>和<strong>快速重新发送</strong>。</p>
<ul>
<li><strong>[2] 超时重新发送</strong></li>
</ul>
<p>我们之前已经简单介绍过重新发送的机制：当发送方送出一个 <code>TCP</code> 片段后，将开始计时，等待该 <code>TCP</code> 片段的 <code>ACK</code> 回复。如果接收方正确接收到符合次序的片段，接收方会利用 <code>ACK</code> 片段回复发送方。发送方得到 <code>ACK</code> 回复后，继续移动窗口，发送接下来的 <code>TCP</code> 片段。如果直到计时完成，发送方还是没有收到<code>ACK</code>回复，那么发送方推断之前发送的 <code>TCP</code> 片段丢失，因此重新发送之前的 <code>TCP</code> 片段。这个计时等待的时间叫做重新发送超时时间(<code>RTO</code>)。</p>
<p>发送方应该在等待多长时间之后重新发送呢？这是重新发送的核心问题。上述过程实际上有往返两个方向：1.发送片段从发送方到接收方的传输，2. <code>ACK</code> 片段从接收方到发送方的传输。整个过程实际耗费的时间称做往返时间(<code>RTT</code>)。如果 <code>RTT</code> 是固定的，比如 <code>1</code> 秒，那么我们可以让 <code>RTO</code> 等于 <code>RTT</code>。但实际上，<code>RTT</code> 的上下浮动很大。比如某个时刻，网络中有许多交通，那么 <code>RTT</code> 就增加。在 <code>RTT</code> 浮动的情况下，如果我们设置了过小的 <code>RTO</code>，那么 <code>TCP</code> 会等待很短的时间之后重新发送，而实际上之前发送的片段并没有丢失，只是传输速度比较慢而已，这样，网络中就被重复注入 <code>TCP</code> 片段，从而浪费网络传输资源。另一方面，如果 <code>RTO</code> 时间过长，那么当 <code>TCP</code> 片段已经实际丢失的情况下，发送方不能及时重新发送，会造成网络资源的闲置。所以，<code>RTO</code> 必须符合当前网络的使用状况。网络状况越好，<code>RTO</code> 应该越短；网络状况越差，<code>RTO</code> 应该越长。</p>
<p><code>TCP</code> 协议通过统计 <code>RTT</code>，来决定合理的 <code>RTO</code>。发送方可以测量每一次 <code>TCP</code> 传输的 <code>RTT</code>(从发送出数据片段开始，到接收到 <code>ACK</code> 片段为止)，这样的每次测量得到的往返时间，叫做采样 <code>RTT</code>。建立连接之后，每次的 <code>srtt</code> 作为采样样本，计算平均值(<code>mean</code>)和标准差(<code>standard deviation</code>)，并让 <code>RTO</code> 等于 srtt 平均值加上四倍的 <code>srtt</code> 标准差。</p>
<pre class="line-numbers language-bash"><code class="language-bash"><span class="token comment" spellcheck="true"># 上述算法有多个变种，根据平台不同有所变化</span>
RTO <span class="token operator">=</span> mean + 4 std<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>平均值反映了平均意义上的 <code>RTT</code>，平均往返时间越大，<code>RTO</code> 越大。另一方面，标准差越大也会影响 <code>RTO</code>。标准差代表了 <code>RTT</code> 样本的离散程度。如果 <code>RTT</code> 上下剧烈浮动，标准差比较大。<code>RTT</code> 浮动大，说明当前网络状况相对不稳定。因此要设置更长的 <code>RTO</code>，以应对不稳定的网络状况。</p>
<ul>
<li><strong>[3] 快速重新发送</strong></li>
</ul>
<p>我们刚才介绍了超时重新发送的机制：发送方送出一个 <code>TCP</code> 片段，然后开始等待并计时，如果 <code>RTO</code> 时间之后还没有收到 <code>ACK</code> 回复，发送方则重新发送。<code>TCP</code> 协议有可能在计时完成之前启动重新发送，也就是利用快速重新发送(<code>fast-retransmission</code>)。快速发送机制如果被启动，将打断计时器的等待，直接重新发送 <code>TCP</code> 片段。</p>
<p>由于 <code>IP</code> 包的传输是无序的，所以接收方有可能先收到后发出的片段，也就是乱序(<code>out-of-order</code>)片段。乱序片段的序号并不等于最近发出的 <code>ACK</code> 回复号。已接收的文本流和乱序片段之间将出现空洞(<code>hole</code>)，也就是等待接收的空位。比如已经接收了正常片段 <code>5</code>/<code>6</code>/<code>7</code>，此时又接收乱序片段 <code>9</code>。这时片段 <code>8</code> 依然空缺，片段 <code>8</code> 的位置就是一个空洞。</p>
<p><code>TCP</code> 协议规定，当接收方收到乱序片段的时候，需要重复发送 <code>ACK</code>。比如接收到乱序片段 <code>9</code> 的时候，接收方需要回复 <code>ACK</code>。回复号为 <code>8</code>(<code>7+1</code>)。此后接收方如果继续收到乱序片段(序号不是 <code>8</code> 的片段)，将再次重复发送 <code>ACK=8</code>。当发送方收到 <code>3</code> 个 <code>ACK=8</code> 的回复时，发送方推断片段 <code>8</code> 丢失。即使此时片段 <code>8</code> 的计时器还没有超时，发送方会打断计时，直接重新发送片段 <code>8</code>，这就是快速重新发送机制(<code>fast-retransmission</code>)。</p>
<p>快速重新发送机制利用重复的 <code>ACK</code> 来提示空洞的存在。当重复次数达到阈值时，认为空洞对应的片段在网络中丢失。快速重新发送机制提高了检测丢失片段的效率，往往可以在超时之前探测到丢失片段，并重复发送丢失的片段。</p>
<ul>
<li><strong>[4] 总结陈述</strong></li>
</ul>
<p>凤凰浴火重生。而 <code>TCP</code> 协议利用重新发送(<code>retransmission</code>)来实现 <code>TCP</code> 传输的可靠性。重新发送的基本形式是超时重新发送，根据统计的往返时间来设置超时标准；如果超时，则重新发送 <code>TCP</code> 片段。另一方面，快速重新发送则通过乱序片段的 <code>ACK</code> 来更早的推断出片段的丢失。</p>
<hr>
<h3 id="4-6-天下为公-TCP-堵塞控制"><a href="#4-6-天下为公-TCP-堵塞控制" class="headerlink" title="4.6 天下为公 (TCP 堵塞控制)"></a>4.6 天下为公 (TCP 堵塞控制)</h3><p>在 <code>TCP</code> 协议中，我们使用连接记录 <code>TCP</code> 两端的状态，使用编号和分段实现了 <code>TCP</code> 传输的有序，使用 <code>advertised window</code> 来实现了发送方和接收方处理能力的匹配，并使用重复发送来实现 <code>TCP</code> 传输的可靠性。我们只需要将 <code>TCP</code> 片段包装成 <code>IP</code> 包，扔到网络中就可以了。<code>TCP</code> 协议的相关模块会帮我们处理各种可能出现的问题(比如排序，比如 <code>TCP</code> 片段丢失等等)。最初的 <code>TCP</code> 协议就是由上述的几大块构成的。</p>
<p>然而进入上世纪八十年代，网络开始变的繁忙。许多网络中出现了大量的堵塞(<code>congestion</code>)。堵塞类似于现实中的堵车。网络被称为“信息高速公路”。许多汽车(<code>IP</code> 包)在网络中行驶，并经过一个一个路口(路由器)，直到到达目的地。一个路由器如果过度繁忙，会丢弃一些 <code>IP</code> 包。<code>UDP</code> 协议不保证传输的可靠性，所以丢失就丢失了。而 <code>TCP</code> 协议需要保证传输的可靠性，当包含有 <code>TCP</code> 片段的 <code>IP</code> 包丢失时，<code>TCP</code> 协议会重复发送 <code>TCP</code> 片段。于是，更多的“汽车”进入到公路中，原本繁忙的路由器变得更加繁忙，更多的 <code>IP</code> 包丢失。这样就构成了一个恶性循环。这样的情况被称为堵塞崩溃(<code>congestion collapse</code>)。每个发送方为了保证自己的发送质量，而不顾及公共领域现状，是造成堵塞崩溃的主要原因。当时的网络中高达 <code>90%</code> 的传输资源可能被堵塞崩溃所浪费。</p>
<p>为了解决这一缺陷，从八十年代开始，<code>TCP</code> 协议中开始加入堵塞控制(<code>congestion control</code>)的功能，以避免堵塞崩溃的出现。多个算法被提出并实施，大大改善了网络的交通状况。直到今天，堵塞控制依然是互联网研究的一个活跃领域。</p>
<ul>
<li><strong>[1] 公德</strong></li>
</ul>
<p>现实中，当我们遇到堵车，可能就会希望兴建立交桥和高架，或者希望有一位交警来疏导交通。而 <code>TCP</code> 协议的堵塞控制是通过约束自己实现的。当 <code>TCP</code> 的发送方探测到网络交通拥堵时，会控制自己发送片段的速率，以缓解网络的交通状况，避免堵塞崩溃。简言之，<code>TCP</code> 协议规定了发送方需要遵守的“公德”。</p>
<p>我们先来说明堵塞是如何探测的。在 <code>TCP</code> 重新发送中，我们已经总结了两种推测 <code>TCP</code> 片段丢失的方法：<code>ACK</code> 超时和重复 <code>ACK</code>。一旦发送方认为 <code>TCP</code> 片段丢失，则认为网络中出现堵塞。另一方面，<code>TCP</code> 发送方是如何控制发送速率呢？<code>TCP</code> 协议通过控制滑窗(<code>sliding window</code>)大小来控制发送速率。在 <code>TCP</code> 滑窗管理中，我们已经见到了一个窗口限制，就是 <code>advertised window size</code>，以实现 <code>TCP</code> 流量控制。<code>TCP</code> 还会维护一个堵塞窗口大小，以根据网络状况来调整滑窗大小。真实滑窗大小取这两个滑窗限制的最小值，从而同时满足两个限制 (流量控制和堵塞控制)。我们将专注于堵塞窗口。(<code>Hulk，smash!</code>)</p>
<ul>
<li><strong>[2] 堵塞窗口</strong></li>
</ul>
<p>堵塞窗口(<code>congestion window</code>)总是处于两种状态的一个。这两种状态是: 慢启动(<code>slow start</code>)和堵塞规避(<code>congestion avoidance</code>)。</p>
<p><img src="../images/learn-tcp-ip-protocol-95.png" alt="堵塞窗口"></p>
<p>上图是概念性的。实际的实施要比上图复杂，而且根据算法不同会有不同的版本。<code>cwnd</code> 代表堵塞窗口大小。我们以片段的个数为单位，来表示 <code>cwnd</code> 的大小 (同样是概念性的)。堵塞窗口从慢启动的状态开始。慢启动的特点是初始速率低，但速率不断倍增。每次进入到慢启动状态时，<code>cwnd</code> 都需要重置为初始值 <code>1</code>。发送方每接收到一个正确的 <code>ACK</code>，就会将堵塞窗口增加 <code>1</code>，从而实现速率的倍增(由于累计 <code>ACK</code>，速率增长可能会小于倍增)。</p>
<p>当堵塞窗口的大小达到某个阈值 <code>ssthresh</code> 时，<code>congestion</code> 进入到堵塞规避(<code>congestion avoidance</code>)状态。发送速率会继续增长。发送方在每个窗户所有片段成功传输后，将窗口尺寸增加 <code>1</code>(实际上就是每个 <code>RTT</code> 增加 <code>1</code>)。所以在堵塞规避状态下，<code>cwnd</code> 线性增长，增长速率慢。如果在堵塞规避下有片段丢失，重新回到慢启动状态，并将 <code>ssthresh</code> 更新为 <code>cwnd</code> 的一半。</p>
<p>我们看到，<code>sshthresh</code> 是慢启动到堵塞规避的切换点。而片段丢失是堵塞规避到慢启动的切换点。一开始 <code>sshthresh</code> 的值一般比较大，所以慢启动可能在切换成堵塞规避之前就丢失片段。这种情况下，慢启动会重新开始，而 <code>ssthresh</code> 更新为 <code>cwnd</code> 的一半。</p>
<p>总的来说，发送速率总是在增长。如果片段丢失，则重置速率为 <code>1</code>，并快速增长。增长到一定程度，则进入到慢性增长。快速增长和慢性增长的切换点(<code>sshthred</code>)会随着网络状况(何时出现片段丢失)更新。通过上面的机制，让发送速率处于动态平衡，不断的尝试更大值。初始时增长块，而接近饱和时增长慢。但一旦尝试过度，则迅速重置，以免造成网络负担。</p>
<ul>
<li><strong>[3] 总结陈述</strong></li>
</ul>
<p>阻塞控制有效的提高了互联网的利用率。阻塞控制的算法多种多样，并且依然不完善。一个常见的问题是 <code>cwnd</code> 在接近饱和时线性增长，因此对新增的网络带宽不敏感。互联网利用“公德”来实现效率。“公德”和效率似乎可以并存。到现在为止，<code>TCP</code> 协议的介绍就可以告一段落了。可以回想一下 <code>TCP</code> 的几大模块：分段与流，滑窗，连接，流量控制，重新发送，堵塞控制。</p>
<hr>
<h2 id="5-应用层"><a href="#5-应用层" class="headerlink" title="5. 应用层"></a>5. 应用层</h2><h3 id="5-1-9527-DNS-协议"><a href="#5-1-9527-DNS-协议" class="headerlink" title="5.1 9527 (DNS 协议)"></a>5.1 9527 (DNS 协议)</h3><ul>
<li><strong>[1] 9527 (DNS 协议)</strong></li>
</ul>
<p>在周星驰的电影《唐伯虎点秋香》中，周星驰饰演的主角一进入华府，就被强制增加了一个代号 <code>9527</code>。从此，华府的人开始称呼主角为 <code>9527</code>，而不是他的姓名。</p>
<p><img src="../images/learn-tcp-ip-protocol-100.png" alt="9527"></p>
<p>域名(<code>domain name</code>)是 <code>IP</code> 地址的代号。域名通常是由字符构成的。对于人类来说，字符构成的域名，比如 <code>www.yahoo.com</code>，要比纯粹数字构成的 <code>IP</code> 地址(<code>106.10.170.118</code>)容易记忆。域名解析系统(<code>DNS</code>，<code>domain name system</code>)就负责将域名翻译为对应的 <code>IP</code> 地址。在 <code>DNS</code> 的帮助下，我们可以在浏览器的地址栏输入域名，而不是 <code>IP</code> 地址。这大大减轻了互联网用户的记忆负担。另一方面，处于维护和运营的原因，一些网站可能会变更 <code>IP</code> 地址。这些网站可以更改 <code>DNS</code> 中的对应关系，从而保持域名不变，而 <code>IP</code> 地址更新。由于大部分用户记录的都是域名，这样就可以降低 <code>IP</code> 变更带来的影响。</p>
<p>从机器和技术的角度上来说，域名并不是必须的。但 <code>Internet</code> 是由机器和用户共同构成的。鉴于 <code>DNS</code> 对用户的巨大帮助，<code>DNS</code> 已经被当作 <code>TCP/IP</code> 套装不可或缺的一个组成部分。</p>
<ul>
<li><strong>[2] DNS 服务器</strong></li>
</ul>
<p>域名和 <code>IP</code> 地址的对应关系存储在 <code>DNS</code> 服务器(<code>DNS server</code>)中。所谓的 <code>DNS</code> 服务器，是指在网络中进行域名解析的一些服务器(计算机)。这些服务器都有自己的 <code>IP</code> 地址，并使用 <code>DNS</code> 协议(<code>DNS protocol</code>)进行通信。<code>DNS</code> 协议主要基于 <code>UDP</code>，是应用层协议(这也是我们见到的第一个应用层协议)。</p>
<p><img src="../images/learn-tcp-ip-protocol-101.png" alt="DNS服务器"></p>
<p><code>DNS</code> 服务器构成一个分级(<code>hierarchical</code>)的树状体系。上图中，每个节点(<code>node</code>)为一个 <code>DNS</code> 服务器，每个节点都有自己的 <code>IP</code> 地址。树的顶端为用户电脑出口处的 <code>DNS</code> 服务器。在 <code>Linux</code> 下，可以使用 <code>cat /etc/resolv.conf</code>，在 <code>Windows</code> 下，可以使用 <code>ipconfig /all</code>，来查询出口 <code>DNS</code> 服务器。树的末端是真正的 <code>域名/IP</code> 对应关系记录。一次 <code>DNS</code> 查询就是从树的顶端节点出发，最终找到相应末端记录的过程。</p>
<p>中间节点根据域名的构成，将 <code>DNS</code> 查询引导向下一级的服务器。比如说一个域名 <code>cs.berkeley.edu</code>，<code>DNS</code> 解析会将域名分割为 <code>cs</code>, <code>berkeley</code>, <code>edu</code>，然后按照相反的顺序查询(<code>edu</code>, <code>berkeley</code>, <code>cs</code>)。出口 DNS 首先根据 <code>edu</code>，将查询指向下一层的 <code>edu</code> 节点。然后 <code>edu</code> 节点根据 <code>berkeley</code>，将查询指向下一层的 <code>berkeley</code> 节点。这台 <code>berkeley</code> 服务器上存储有 cs.berkeley.edu 的 IP 地址。所以，中间节点不断重新定向，并将我们引导到正确的记录。</p>
<p>在整个 <code>DNS</code> 查询过程中，无论是重新定向还是最终取得对应关系，都是用户计算机和 <code>DNS</code> 服务器使用 <code>DNS</code> 协议通信。用户计算机根据 <code>DNS</code> 服务器的反馈，依次与下一层的 <code>DNS</code> 服务器建立通信。用户计算机经过递归查询，最终和末端节点通信，并获得 <code>IP</code> 地址。</p>
<p><img src="../images/learn-tcp-ip-protocol-102.png" alt="DNS服务器"></p>
<ul>
<li><strong>[3] 缓存</strong></li>
</ul>
<p>用户计算机的操作系统中的域名解析模块(<code>DNS Resolver</code>)负责域名解析的相关工作。任何一个应用程序(邮件，浏览器)都可以通过调用该模块来进行域名解析。</p>
<p>并不是每次域名解析都要完整的经历解析过程。<code>DNS Resolver</code> 通常有 <code>DNS</code> 缓存(<code>cache</code>)，用来记录最近使用和查询的 <code>域名/IP</code> 关系。在进行 <code>DNS</code> 查询之前，计算机会先查询 <code>cache</code> 中是否有相关记录。这样，重复使用的域名就不用总要经过整个递归查询过程。</p>
<p><img src="../images/learn-tcp-ip-protocol-103.png" alt="缓存"></p>
<ul>
<li><strong>[4] 反向 DNS</strong></li>
</ul>
<p>上面的 <code>DNS</code> 查询均为正向 <code>DNS</code> 查询：已经知道域名，想要查询对应 <code>IP</code>。而反向 <code>DNS</code>(<code>reverse DNS</code>)是已经知道 <code>IP</code> 的前提下，想要查询域名。反向 <code>DNS</code> 也是采用分层查询方式，对于一个 <code>IP</code> 地址(比如 <code>106.10.170.118</code>)，依次查询 <code>in-addr.arpa</code> 节点(如果是 <code>IPv6</code>，则为 <code>ip6.arpa</code> 节点)，<code>106</code> 节点，<code>10</code> 节点，<code>170</code> 节点，并在该节点获得 <code>106.10.170.118</code> 对应的域名。</p>
<hr>
<h3 id="5-2-先生，要点单吗-HTTP-协议"><a href="#5-2-先生，要点单吗-HTTP-协议" class="headerlink" title="5.2 先生，要点单吗? (HTTP 协议)"></a>5.2 先生，要点单吗? (HTTP 协议)</h3><p>我们在 <code>TCP</code> 流通信中说明了，<code>TCP</code> 协议实现了数据流的传输。然而，在实践中发现，人们往往习惯以文件为单位传输资源，比如文本文件，图像文件，超文本文档(<code>hypertext document</code>)。超文本文档中包含有超链接，指向其他的资源。超文本文档是万维网(<code>World Wide Web</code>，即 <code>www</code>)的基础。<code>HTTP</code> 协议是应用层协议，它随着万维网发展起来。<code>HTTP</code> 协议最初只是一套实践标准。其本质目的是，如何在万维网的网络环境下，更好的使用 <code>TCP</code> 协议(尽管 <code>HTTP</code> 协议也可以用 <code>UDP</code> 协议作为底层，但绝大部分都是基于 <code>TCP</code> 协议)，以实现文件，特别是超文本文件的传输。</p>
<p>早期的 <code>HTTP</code> 协议主要是传输静态文件，也就是存储在服务器上的文件。随着万维网的发展，<code>HTTP</code> 协议被用于传输“动态文件”，这样的文件是服务器上的程序根据 <code>HTTP</code> 请求即时生成的文件。我们将 <code>HTTP</code> 的传输对象统称为资源(<code>resource</code>)。</p>
<ul>
<li><strong>[1] 点单</strong></li>
</ul>
<p><code>HTTP</code> 实现的是资源的订购和传送。其工作方式类似于快餐点单。请求(<code>request</code>): 顾客向服务员提出请求：“来个鸡腿汉堡”。回复(<code>response</code>):服务员根据情况，回应顾客的请求</p>
<p>根据情况的不同，服务员的回应可能有: 服务员准备鸡腿汉堡，将鸡腿汉堡交给顾客（一切 <code>OK</code>）。；服务员发现自己只是个甜品站。他让顾客前往正式柜台点单（重新定向）。；服务员告诉顾客鸡腿汉堡没有了(无法找到)。交易结束后，服务员就将刚才的交易抛到脑后，准备服务下一位顾客。</p>
<ul>
<li><strong>[2] 格式</strong></li>
</ul>
<p><code>HTTP</code> 协议的通信是一次 <code>request-responce</code> 交流。客户端(<code>guest</code>)向服务器发出请求(<code>request</code>)，服务器(<code>server</code>)回复(<code>response</code>)客户端。</p>
<p><img src="../images/learn-tcp-ip-protocol-104.png" alt="格式"></p>
<p><code>HTTP</code> 协议规定了请求和回复需要遵循的格式。请求和回复需要满足下面的格式:</p>
<pre class="line-numbers language-bash"><code class="language-bash">    起始行 <span class="token punctuation">(</span>start line<span class="token punctuation">)</span>
    头信息 <span class="token punctuation">(</span>headers<span class="token punctuation">)</span>

    主体<span class="token punctuation">(</span>entity body<span class="token punctuation">)</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre>
<p><strong>起始行</strong>只有一行。它包含了请求/回复最重要的信息。请求的起始行表示(顾客)“想要什么”。回复的起始行表示(后厨)“发生什么”。</p>
<p><strong>头信息</strong>可以有多行。每一行是一对<strong>键值对</strong>(<code>key-value pair</code>)，比如:</p>
<pre class="line-numbers language-bash"><code class="language-bash">Content-type: text/plain<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>它表示，包含有一个名为 <code>Content-type</code> 的参数，该参数的值为 <code>text/plain</code>。头信息是对起始行的补充。请求的头信息对服务器有指导意义(好像在菜单上注明: 鸡腿不要辣)。回复的头信息则是提示客户端（比如，在盒子上注明: 小心烫）</p>
<p><strong>主体</strong>部分包含了具体的资源。上图的请求中并没有主体，因为我们只是在下单，而不用该后厨送什么东西(请求是可以有主体内容的)。回复中包含的主体是一段文本文字(<code>Hello World!</code>)。这段文本文字正是顾客所期待的，鸡腿汉堡。</p>
<ul>
<li><strong>[3] 请求</strong></li>
</ul>
<p>我们深入一些细节。先来看一下请求:</p>
<pre class="line-numbers language-bash"><code class="language-bash">    GET /index.html HTTP/1.1
    Host: www.example.com<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>
<p>在起始行中，有三段信息:</p>
<ul>
<li><code>GET</code> 方法。用于说明想要服务器执行的操作。</li>
<li><code>/index.html</code> 资源的路径。这里指向服务器上的 <code>index.html</code> 文件。</li>
<li><code>HTTP/1.1</code> 协议的版本。<code>HTTP</code> 第一个广泛使用的版本是 <code>1.0</code>，当前版本为 <code>1.1</code>。</li>
</ul>
<p>早期的 <code>HTTP</code> 协议只有 <code>GET</code> 方法。遵从 <code>HTTP</code> 协议，服务器接收到 <code>GET</code> 请求后，会将特定资源传送给客户。这类似于客户点单，并获得汉堡的过程。使用 GET 方法时，是客户向服务器索取资源，所以请求往往没有主体部分。</p>
<p><code>GET</code> 方法也可以用于传输一些不重要的数据。它是通过改写 <code>URL</code> 的方式实现的。<code>GET</code> 的数据利用 <code>URL?变量名＝变量值</code> 的方法传输。比如向 <code>&lt;http://127.0.0.1&gt;</code> 发送一个变量 <code>“q”</code>，它的值为 <code>“a”</code>。那么，实际的 <code>URL</code> 为 <code>&lt;http://127.0.0.1?q=a&gt;</code>。服务器收到请求后，就可以知道 <code>"q"</code> 的值为 <code>"a"</code>。</p>
<p><code>ET</code> 方法之外，最常用的是 <code>POST</code> 方法。它用于从客户端向服务器提交数据。使用 <code>POST</code> 方法时，<code>URL</code> 不再被改写。数据位于 <code>http</code> 请求的主体。<code>POST</code> 方法最用于提交 <code>HTML</code> 的 <code>form</code> 数据。服务器往往会对 <code>POST</code> 方法提交的数据进行一定的处理，比如存入服务器数据库。</p>
<p>样例请求中有一行头信息。该头信息的名字是 <code>Host</code>。<code>HTTP</code> 的请求必须有 <code>Host</code> 头信息，用于说明服务器的地址和端口。<code>HTTP</code> 协议的默认端口是 <code>80</code>，如果在 <code>HOST</code> 中没有说明端口，那么将默认采取该端口。在该例子中，服务器的域名为 <code>www.example.com</code>，端口为 80。域名将通过 <code>DNS</code> 服务器转换为 <code>IP</code> 地址，从而确定服务器在互联网上的地址。</p>
<ul>
<li><strong>[4] 回复</strong></li>
</ul>
<p>服务器在接收到请求之后，会根据程序，生成对应于该请求的回复，比如:</p>
<pre class="line-numbers language-bash"><code class="language-bash">    HTTP/1.1 200 OK
    Content-type: text/plain
    Content-length: 12

    Hello World<span class="token operator">!</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>
<p>回复的起始行同样包含三段信息</p>
<ul>
<li><code>HTTP/1.1</code> 协议版本</li>
<li><code>200</code> 状态码(<code>status code</code>)。</li>
<li><code>OK</code> 状态描述</li>
</ul>
<p><code>OK</code> 是对状态码 <code>200</code> 的文字描述，它只是为了便于人类的阅读。电脑只关心三位的状态码(<code>status code</code>)，即这里的 <code>200</code>。<code>200</code> 表示一切 <code>OK</code>，资源正常返回。状态码代表了服务器回应动作的类型。</p>
<p>其它常见的状态码还有:</p>
<ul>
<li><code>302</code>，重新定向(<code>redirect</code>): 我这里没有你想要的资源，但我知道另一个地方 <code>xxx</code> 有，你可以去那里找。</li>
<li><code>404</code>，无法找到(<code>not found</code>): 我找不到你想要的资源，无能为力。</li>
</ul>
<p><code>Content-type</code> 说明了主体所包含的资源的类型。根据类型的不同，客户端可以启动不同的处理程序(比如显示图像文件，播放声音文件等等)。下面是一些常见的资源</p>
<ul>
<li><code>text/plain</code> 普通文本</li>
<li><code>text/html</code> HTML 文本</li>
<li><code>image/jpeg</code> jpeg 图片</li>
<li><code>image/gif</code> gif 图片</li>
</ul>
<p><code>Content-length</code> 说明了主体部分的长度，以字节(<code>byte</code>)为单位。</p>
<p>回应的主体部分为一段普通文本，即 <code>Hello World!</code>。</p>
<ul>
<li><strong>[5] 无状态</strong></li>
</ul>
<p>根据早期的 <code>HTTP</code> 协议，每次 <code>request-reponse</code> 时，都要重新建立 <code>TCP</code> 连接。<code>TCP</code> 连接每次都重新建立，所以服务器无法知道上次请求和本次请求是否来自于同一个客户端。因此，<code>HTTP</code> 通信是无状态(<code>stateless</code>)的。服务器认为每次请求都是一个全新的请求，无论该请求是否来自同一地址。</p>
<p>想象高级餐厅和快餐店。高级餐厅会知道客人所在的位置，如果新增点单，那么服务员知道这和上一单同一桌。而在快餐店中，不好意思，服务员并不记录客人的特征。想再次点单？请重新排队……随着 <code>HTTP</code> 协议的发展，<code>HTTP</code> 协议允许 <code>TCP</code> 连接复用，以节省建立连接所耗费的时间。但 <code>HTTP</code> 协议依然保持无状态的特性。</p>
<hr>
<h3 id="5-3-小美的桌号-DHCP-协议"><a href="#5-3-小美的桌号-DHCP-协议" class="headerlink" title="5.3 小美的桌号 (DHCP 协议)"></a>5.3 小美的桌号 (DHCP 协议)</h3><p><code>DHCP</code> 协议用于动态的配置电脑的网络相关参数，如主机的 <code>IP</code> 地址，路由器出口地址、<code>DNS</code> 域名服务器地址等。一台电脑只要接上网，就可以通过 <code>DHCP</code> 协议获得相关配置，从而顺利的畅游网络。</p>
<ul>
<li><strong>[1] 网络配置</strong></li>
</ul>
<p>电脑刚刚接上网络时，像一个走入一家新餐厅的食客，不免会有很多疑惑。如果顾客的问题长时间得不到解答，那么餐厅很可能失去这位客人。于是，餐厅往往会雇一些服务员。他们可以把客人引导到空闲的座位，并告诉顾客如何点餐、如何结账等。同样，在网络通信中，一台电脑需要设置自己的 <code>IP</code> 地址等网络参数。可对于电脑用户来说，这些设置太过复杂。幸好，<code>DHCP</code> 协议可以解决这一让人头痛的问题。</p>
<p><code>DHCP</code> 协议全称为“动态主机设置协议”（<code>Dynamic Host Configuration Protocol</code>）。通常来说，普通电脑中都内置有 <code>DHCP</code> 客户端模块。电脑接上网络后，<code>DHCP</code> 客户端发现新连通的网络，会在该网络上找 <code>DHCP</code> 服务器。<code>DHCP</code> 服务器将给电脑提供合理的网络配置，并把设置信息传回本机。所谓的 <code>DHCP</code> 服务器，其实就是一些运行有 <code>DHCP</code> 服务器端软件的特殊电脑。他们像等候在网络上的服务员，为新来的顾客排忧解难。本机和 <code>DHCP</code> 服务器之间的通信，都是通过 <code>DHCP</code> 协议进行的。</p>
<p>其实在网络诞生初期，就有了用一台服务器为网络上的电脑配置参数的做法。最早的一个协议叫 <code>BOOTP</code>（<code>Bootstrap Protocol</code>），主要用于开机配置。计算机开机时需要很多配置参数。对于没有磁盘的计算机来说，它无法获得这些参数，但可以通过 <code>BOOTP</code> 从网络上的其他设备上获得。<code>DHCP</code> 大体上继承了 <code>BOOTP</code> 的工作方式，但在细节上进行了改进。我们将在以后看到。</p>
<ul>
<li><strong>[2] 地址分配</strong></li>
</ul>
<p>服务员最重要的任务是为客人找座位。类似的，<code>DHCP</code> 服务器的首要任务是分配 <code>IP</code> 地址。分配的 <code>IP</code> 地址要符合以下原则：</p>
<ol>
<li>地址合法，即对应该局域网的 <code>IP</code> 地址和子网掩码。</li>
<li>地址空闲，同一网络下没有其他设备使用该地址。</li>
</ol>
<p><code>DHCP</code> 服务器上存有一个地址池，里面是可用的 <code>IP</code> 地址，相当于服务员手中的空闲桌号列表。当新客人出现时，<code>DHCP</code> 服务器就会从地址池中取出一个 <code>IP</code> 地址分配给客人。此外，服务器还会说明 <code>IP</code> 地址的占用时间，也就是租期。</p>
<p>当然，主机使用网络的时间可能超过租期。如果主机在租期到时都没有联系 <code>DHCP</code> 服务器，那么 <code>DHCP</code> 服务器会收回 <code>IP</code> 地址，再分配给其他主机。可如果主机想继续使用 <code>IP</code> 地址，就要在中途申请延长租期。收到申请的 <code>DHCP</code> 服务器通常会答应主机的请求，允许它继续使用现有 <code>IP</code> 地址。但少数情况下，服务器会要求主机更换 IP 地址。如果主机联系不上 <code>DHCP</code> 服务器，那么它必须立即停止使用 <code>IP</code> 地址，重启寻找 <code>DHCP</code> 服务器的过程。</p>
<p>有了动态分配，<code>DHCP</code> 服务器不但简化了网络配置过程，还可以有效利用 <code>IP</code> 地址资源。例如一个咖啡馆的 <code>Wifi</code> 路由允许 <code>200</code> 台设备接入。咖啡馆每天进出的客人很多。如果每个客人都要求一个不一样的 <code>IP</code> 地址的话，所需地址会远远超过 <code>200</code> 台。而通过动态的方式，<code>200</code> 个 <code>IP</code> 地址不断回收使用，完全可以满足客人的需要。有时，<code>DHCP</code> 服务器会预留一些地址给特定 <code>MAC</code> 地址的设备使用。这就好像餐厅给贵宾预留座位，不允许其他客人坐。这样的地址通常会分配给打印机、传真机等特殊设备。由于 <code>IP</code> 地址固定，用户可以方便的通过 <code>IP</code> 地址找到它们。</p>
<ul>
<li><strong>[3] 通信过程</strong></li>
</ul>
<p><code>DHCP</code> 协议的底层是 <code>UDP</code> 协议。我们知道，网络上的点对点沟通需要有 <code>IP</code> 地址。但新接入网络的客户机正是想通过 <code>DHCP</code> 通信来获得 <code>IP</code> 地址。这简直成了“鸡生蛋、蛋生鸡”的死胡同。幸好，除了点对点通信，<code>UDP</code> 协议还允许广播通信。把 <code>UDP</code> 数据包发送到网络的广播地址，网络上的每个设备都能收到。因此，<code>DHCP</code> 通信主要靠这种广播的形式进行。</p>
<p><code>DHCP</code> 通信分为四步：</p>
<ol>
<li><code>Discovery</code>：客户机发广播，搜寻 <code>DHCP</code> 服务器。</li>
<li><code>Offer</code>：<code>DHCP</code> 服务器发出邀请，提供一个可用的 <code>IP</code> 地址。</li>
<li><code>Request</code>：客户机正式请求使用该 <code>IP</code> 地址。</li>
<li><code>Acknowledge</code>：<code>DHCP</code> 服务器确认，并提供其他配置参数。</li>
</ol>
<p><img src="../images/learn-tcp-ip-protocol-105.png" alt="DHCP通信分为四步"></p>
<p>每一步的通信内容都放在一个符合 <code>DHCP</code> 格式的数据包中。数据包中可以包括客户机 <code>IP</code> 地址、服务器 <code>IP</code> 地址、客户的硬件 <code>MAC</code> 编号等字段，还能附加多条网络设置参数。当某些信息未知时，如客户机的 <code>IP</code> 地址，相应的字段可以填成 <code>0</code>。</p>
<p>经过这一系列的 <code>DHCP</code> 通信，客户机获得了自己的 <code>IP</code> 地址，也记下了租期时间。为了防止 <code>DHCP</code> 服务器不靠谱，客户机通常还会探测一下网络，以免该 <code>IP</code> 已经被其他设备占用。除了租期，<code>DHCP</code> 服务器最终确认中，还可能加上其他网络配置信息，如 <code>DNS</code> 服务器地址、网络出口地址等。客户机可以选择接受，也可以拒绝 <code>DHCP</code> 服务器的“好意”，自行设置这些参数。</p>
<ul>
<li><strong>[4] DHCP 攻击</strong></li>
</ul>
<p>一定程度上说，<code>DHCP</code> 服务器是个活雷锋，为网络上的其他设备提供公共服务，免得设备之间私自打架。人们也越来越信赖这个活雷锋，只管接上网线、连上 <code>Wifi</code>，让 <code>DHCP</code> 服务器处理配置之类的杂事。无形中，<code>DHCP</code> 服务器掌握了很大的公共权力。一些黑客攻击手法开始瞄准 <code>DHCP</code> 服务器。</p>
<p>针对 <code>DHCP</code> 的一种攻击办法是从服务器那里骗 <code>IP</code> 地址。攻击者的电脑可以不断发出 DHCP 请求，冒充成新入网的客户机。于是，<code>DHCP</code> 服务器的地址池被耗干，无法分配地址给后来的用户。后来的用户再也没法使用网络服务。攻击者很可能会继续下连环套。攻击者占有了大量 <code>IP</code> 地址，可以装扮成新的 <code>DHCP</code> 服务器，把自己骗来的 <code>IP</code> 地址分配给网络上的新用户。</p>
<p>当然不是。<code>DHCP</code> 服务器还能提供其他网络设置参数。攻击者可以让自己成为 <code>DNS</code> 服务器或者网络出口。于是，客户机的域名解析和外网通信，必须经过攻击者的电脑。这个时候，攻击者的权限就很大了。他可以偷听通信、伪装成客户机、假扮成某个域名的网站。比如说，攻击者就可以篡改域名解析，让你在访问 <code>www.cnblogs.com/vamei</code> 时，实际上访问的是攻击者提供的一个网页。当你在这个网页上输入用户名和密码时，你的信息就完全泄露给了攻击者。</p>
<p><code>DHCP</code> 攻击让人防不胜防。<code>DHCP</code> 协议在设计中并没有考虑到安全性的问题，所以很难从软件上杜绝 <code>DHCP</code> 攻击。某些品牌的交换机上，可以指定特定端口给合法的 <code>DHCP</code> 服务器，以免其他人伪装。当然，最重要的保护方式，还是防止攻击者连入局域网。</p>
<ul>
<li><strong>[5] 总结陈述</strong></li>
</ul>
<p><code>DHCP</code> 服务器可以动态的分配 <code>IP</code> 地址，还可以提供其他网络设置参数。客户机和服务器经过四步来完成 <code>DHCP</code> 通信。</p>
<hr>
<h3 id="5-4-我和你的悄悄话-SSL-TLS-协议"><a href="#5-4-我和你的悄悄话-SSL-TLS-协议" class="headerlink" title="5.4 我和你的悄悄话 (SSL/TLS 协议)"></a>5.4 我和你的悄悄话 (SSL/TLS 协议)</h3><p><code>TLS</code> 名为传输层安全协议(<code>Transport Layer Security Protocol</code>)，这个协议是一套加密的通信协议。它的前身是 <code>SSL</code> 协议(安全套接层协议)。这两个协议的工作方式类似，但 <code>TLS</code> 协议针对 <code>SSL</code> 协议进行了一些改善。<code>SSL/TLS</code> 协议利用加密的方式，在开放的互联网环境中实现了加密通信，让通信的双方可以安心的说悄悄话。</p>
<ul>
<li><strong>[1] 加密</strong></li>
</ul>
<p><code>SL</code> 协议的基础是加密技术。加密和解密是自古就有技术了。比如说古代的男女偷偷发生私情，不能被相互之间有血海深仇的两个家族知道。男孩问女孩要不要一起私奔。女孩第二天传来答复，上面写着：</p>
<pre class="line-numbers language-bash"><code class="language-bash">K FQ<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>男孩拿着这串字符翻来覆去想了半天，没明白女孩的意思，就以为女孩不愿放弃优渥的生活和他私奔。直到十年后，男孩忽然灵光一闪，发现如果把每个字母都替换成字母表上提前两个的字母的话，这三个字符就变成了：</p>
<pre class="line-numbers language-bash"><code class="language-bash">I DO<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>
<p>这种加密方法是将原来的某种信息按照某个规律打乱。打乱的方式称为加密算法，而打乱过程中的参数就叫做密钥(<code>cipher code</code>)。上面女孩的加密方式是把原字母替换为字母表上后固定位的字母。而密钥就是固定的位数 <code>2</code> 了。发出信息的人根据密钥来给信息加密，而接收信息的人利用相同的密钥，来给信息解密。就好像一个带锁的盒子。发送信息的人将信息放到盒子里，用钥匙锁上。而接受信息的人则用相同的钥匙打开。加密和解密用的是同一个密钥，这种加密称为对称加密。</p>
<p>如果一对一的话，那么两人需要交换一个密钥。理论上，如果密钥绝对安全，而且加密算法绝对复杂的话，对称加密是很难破解的。但通信双方很难绝对保证密钥的安全。一旦有其他人窃取到密钥，那么所有通信都变得不安全了。特别在一对多的话，如果共用同一套密钥，那么某一方通信的破解就意味着所有通信的破解。二战中盟军的情报战成果，很多都来自于破获这种对称加密的密钥。盟军破解了某个德国特工的加密手法，那么也就了解到纳粹总部的加密手法了。</p>
<p>对称加密的薄弱之处在于给了太多人的钥匙。如果换一种思路，只给特工锁，而总部保有钥匙，那就容易了。特工将信息用锁锁到盒子里，谁也打不开，除非到总部用唯一的一把钥匙打开。只是这样的话，特工每次出门都要带上许多锁，太容易被识破身份了。总部老大想了想，干脆就把造锁的技术公开了。特工，或者任何其它人，可以就地取材，按照图纸造锁，但无法根据图纸造出钥匙。钥匙只有总部的那一把。上面的关键是锁和钥匙工艺不同。知道了锁，并不能知道钥匙。这样，总部可以将“造锁”的方法公布给所有用户。每个用户可以用锁来加密自己的信用卡信息。即使被别人窃听到，也不用担心：只有总部才有钥匙呢！非对称加密中，给所有人用的锁被称为公钥(<code>public key</code>)，总部自己保留的钥匙被称为私钥(<code>private key</code>)。这样一种钥匙和锁分离的加密算法就叫做非对称加密。</p>
<ul>
<li><strong>[2] 非对称加密</strong></li>
</ul>
<p>对称加密的原理相对比较直观，而非对称加密听起来就有些神奇。经过非对称加密产生的密文，就算知道加密的方法，也无法获知原文。实现了非对称加密的经典算法是 <code>RSA</code> 算法。它来自于数论与计算机计数的奇妙结合。我们从下面的情境中体验一下 <code>RSA</code> 算法的妙处。</p>
<p><img src="../images/learn-tcp-ip-protocol-106.png" alt="非对称加密"></p>
<p><img src="../images/learn-tcp-ip-protocol-107.png" alt="非对称加密"></p>
<ul>
<li><strong>[3] SSL 协议</strong></li>
</ul>
<p>可以看到，非对称加密从安全性上要强过对称加密。但天下没有免费的午餐。非对称加密的运算成本同样也比较高。为了兼顾效率和安全，<code>SSL</code> 协议同时使用了非对称和对称加密。它用对称加密算法来加密信息本身。但对于安全性比较脆弱的对称加密密钥，则采用非对称加密的方式来传输。</p>
<p><code>SSL</code> 协议分为客户端和服务器端。通信的核心步骤很简单：</p>
<ol>
<li>双方利用明文通信的方式确立使用的加密算法。</li>
<li>利用非对称算法通信，交换一个密钥。</li>
<li>该密钥用于对称加密算法，加密接下来的通信正文。</li>
</ol>
<p>可以看到，<code>SSL</code> 协议的关键是用一个非常安全的方式来交换一个对称密钥。交换的过程会比上面的描述更加复杂一些。</p>
<ol>
<li>客户发起请求时，除了说明自己支持的非对称加密算法，还会附加一个客户端随机数(<code>client random</code>)。</li>
<li>服务器回复请求时，会确定非对称加密算法和哈希函数，并附上公钥。此外，服务器端还会在此次通信中附加一个服务器端随机数(<code>server random</code>)。</li>
<li>客户端会产生第三个随机数(<code>Premaster secret</code>)，然后利用服务器确定的非对称加密算法和公钥来加密这个随机数，再发送给服务器端。</li>
<li>客户端用自己的私钥解密第三个随机数。</li>
<li>这样，客户端和服务器端都知道了三个随机数。双方各自用商量好的哈希函数从三个随机数获得对称加密的密钥。</li>
</ol>
<p>即使明文通信的时候，某些信息被窃听，但第三步的非对称加密通信部分可以保证窃听者无法完整的获得三个随机数。这样，窃听者还是不知道对称加密的密钥是什么。这样，对称加密的密钥就在一个安全的环境中获得了。为了进一步安全，服务器的公钥会包含在一个数字证书中发送给客户。这样，客户还可以通过数字证书来验证服务器的身份，以免服务器本身出现问题。</p>
<p>今年来使用越来越广泛的 <code>HTTPS</code> 协议就是在 <code>SSL/TLS</code> 协议的基础上进行通信。<code>HTTP</code> 协议在通信过程中要经过多重路由，很容易被窃听。经过 <code>SSL</code> 协议加密的信息就算被窃听，也只能被通信目的地的人解读，从而保证了信息的安全。所以，如果所访问的网站没有使用 <code>HTTPS</code> 协议，那么在输入银行账号和密码之类的敏感信息时，就要三思而后行了。</p>
<p><img src="../images/learn-tcp-ip-protocol-108.png" alt="SSL协议"></p>
<script>
        document.querySelectorAll('.github-emoji')
          .forEach(el => {
            if (!el.dataset.src) { return; }
            const img = document.createElement('img');
            img.style = 'display:none !important;';
            img.src = el.dataset.src;
            img.addEventListener('error', () => {
              img.remove();
              el.style.color = 'inherit';
              el.style.backgroundImage = 'none';
              el.style.background = 'none';
            });
            img.addEventListener('load', () => {
              img.remove();
            });
            document.body.appendChild(img);
          });
      </script>
            </div>
            <hr/>

            

    <div class="reprint" id="reprint-statement">
        
            <div class="reprint__author">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-user">
                        文章作者:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="/about" rel="external nofollow noreferrer">Escape</a>
                </span>
            </div>
            <div class="reprint__type">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-link">
                        文章链接:
                    </i>
                </span>
                <span class="reprint-info">
                    <a href="https://escapelife.github.io/posts/20285ef8.html">https://escapelife.github.io/posts/20285ef8.html</a>
                </span>
            </div>
            <div class="reprint__notice">
                <span class="reprint-meta" style="font-weight: bold;">
                    <i class="fas fa-copyright">
                        版权声明:
                    </i>
                </span>
                <span class="reprint-info">
                    本博客所有文章除特別声明外，均采用
                    <a href="https://creativecommons.org/licenses/by/4.0/deed.zh" rel="external nofollow noreferrer" target="_blank">CC BY 4.0</a>
                    许可协议。转载请注明来源
                    <a href="/about" target="_blank">Escape</a>
                    !
                </span>
            </div>
        
    </div>

    <script async defer>
      document.addEventListener("copy", function (e) {
        let toastHTML = '<span>复制成功，请遵循本文的转载规则</span><button class="btn-flat toast-action" onclick="navToReprintStatement()" style="font-size: smaller">查看</a>';
        M.toast({html: toastHTML})
      });

      function navToReprintStatement() {
        $("html, body").animate({scrollTop: $("#reprint-statement").offset().top - 80}, 800);
      }
    </script>



            <div class="tag_share" style="display: block;">
                <div class="post-meta__tag-list" style="display: inline-block;">
                    
                        <div class="article-tag">
                            
                                <a href="/tags/Algorithm/">
                                    <span class="chip bg-color">Algorithm</span>
                                </a>
                            
                        </div>
                    
                </div>
                <div class="post_share" style="zoom: 80%; width: fit-content; display: inline-block; float: right; margin: -0.15rem 0;">
                    <link rel="stylesheet" type="text/css" href="/libs/share/css/share.min.css">
<div id="article-share">

    
    <div class="social-share" data-sites="twitter,facebook,google,qq,qzone,wechat,weibo,douban,linkedin" data-wechat-qrcode-helper="<p>微信扫一扫即可分享！</p>"></div>
    <script src="/libs/share/js/social-share.min.js"></script>
    

    

</div>

                </div>
            </div>
            
                <style>
    #reward {
        margin: 40px 0;
        text-align: center;
    }

    #reward .reward-link {
        font-size: 1.4rem;
        line-height: 38px;
    }

    #reward .btn-floating:hover {
        box-shadow: 0 6px 12px rgba(0, 0, 0, 0.2), 0 5px 15px rgba(0, 0, 0, 0.2);
    }

    #rewardModal {
        width: 320px;
        height: 350px;
    }

    #rewardModal .reward-title {
        margin: 15px auto;
        padding-bottom: 5px;
    }

    #rewardModal .modal-content {
        padding: 10px;
    }

    #rewardModal .close {
        position: absolute;
        right: 15px;
        top: 15px;
        color: rgba(0, 0, 0, 0.5);
        font-size: 1.3rem;
        line-height: 20px;
        cursor: pointer;
    }

    #rewardModal .close:hover {
        color: #ef5350;
        transform: scale(1.3);
        -moz-transform:scale(1.3);
        -webkit-transform:scale(1.3);
        -o-transform:scale(1.3);
    }

    #rewardModal .reward-tabs {
        margin: 0 auto;
        width: 210px;
    }

    .reward-tabs .tabs {
        height: 38px;
        margin: 10px auto;
        padding-left: 0;
    }

    .reward-content ul {
        padding-left: 0 !important;
    }

    .reward-tabs .tabs .tab {
        height: 38px;
        line-height: 38px;
    }

    .reward-tabs .tab a {
        color: #fff;
        background-color: #ccc;
    }

    .reward-tabs .tab a:hover {
        background-color: #ccc;
        color: #fff;
    }

    .reward-tabs .wechat-tab .active {
        color: #fff !important;
        background-color: #22AB38 !important;
    }

    .reward-tabs .alipay-tab .active {
        color: #fff !important;
        background-color: #019FE8 !important;
    }

    .reward-tabs .reward-img {
        width: 210px;
        height: 210px;
    }
</style>

<div id="reward">
    <a href="#rewardModal" class="reward-link modal-trigger btn-floating btn-medium waves-effect waves-light red">赏</a>

    <!-- Modal Structure -->
    <div id="rewardModal" class="modal">
        <div class="modal-content">
            <a class="close modal-close"><i class="fas fa-times"></i></a>
            <h4 class="reward-title">你的赏识是我前进的动力</h4>
            <div class="reward-content">
                <div class="reward-tabs">
                    <ul class="tabs row">
                        <li class="tab col s6 alipay-tab waves-effect waves-light"><a href="#alipay">支付宝</a></li>
                        <li class="tab col s6 wechat-tab waves-effect waves-light"><a href="#wechat">微 信</a></li>
                    </ul>
                    <div id="alipay">
                        <img src="/medias/reward/alipay.jpg" class="reward-img" alt="支付宝打赏二维码">
                    </div>
                    <div id="wechat">
                        <img src="/medias/reward/wechat.png" class="reward-img" alt="微信打赏二维码">
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>

<script>
    $(function () {
        $('.tabs').tabs();
    });
</script>

            
        </div>
    </div>

    

    

    

    

    

    

    

<article id="prenext-posts" class="prev-next articles">
    <div class="row article-row">
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge left-badge text-color">
                <i class="fas fa-chevron-left"></i>&nbsp;上一篇</div>
            <div class="card">
                <a href="/posts/e72ea82b.html">
                    <div class="card-image">
                        
                        <img src="/images/frontend-problem-summary.jpg" class="responsive-img" alt="前端疑难杂症汇总">
                        
                        <span class="card-title">前端疑难杂症汇总</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                        <span class="publish-date">
                            <i class="far fa-clock fa-fw icon-date"></i>2020-07-30
                        </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Web进击之旅/" class="post-category">
                                    Web进击之旅
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Frontend/">
                        <span class="chip bg-color">Frontend</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
        
        <div class="article col s12 m6" data-aos="fade-up">
            <div class="article-badge right-badge text-color">
                下一篇&nbsp;<i class="fas fa-chevron-right"></i>
            </div>
            <div class="card">
                <a href="/posts/f9416941.html">
                    <div class="card-image">
                        
                        <img src="/images/heaven-no-regrets.jpg" class="responsive-img" alt="愿天堂没有遗憾">
                        
                        <span class="card-title">愿天堂没有遗憾</span>
                    </div>
                </a>
                <div class="card-content article-content">
                    <div class="summary block-with-text">
                        
                            
                        
                    </div>
                    <div class="publish-info">
                            <span class="publish-date">
                                <i class="far fa-clock fa-fw icon-date"></i>2020-07-17
                            </span>
                        <span class="publish-author">
                            
                            <i class="fas fa-bookmark fa-fw icon-category"></i>
                            
                            <a href="/categories/Wen文所未闻/" class="post-category">
                                    Wen文所未闻
                                </a>
                            
                            
                        </span>
                    </div>
                </div>
                
                <div class="card-action article-tags">
                    
                    <a href="/tags/Essays/">
                        <span class="chip bg-color">Essays</span>
                    </a>
                    
                </div>
                
            </div>
        </div>
        
    </div>
</article>

</div>



<!-- 代码块功能依赖 -->
<script type="text/javascript" src="/libs/codeBlock/codeBlockFuction.js"></script>

<!-- 代码语言 -->

<script type="text/javascript" src="/libs/codeBlock/codeLang.js"></script>


<!-- 代码块复制 -->

<script type="text/javascript" src="/libs/codeBlock/codeCopy.js"></script>


<!-- 代码块收缩 -->

<script type="text/javascript" src="/libs/codeBlock/codeShrink.js"></script>


<!-- 代码块折行 -->

<style type="text/css">
code[class*="language-"], pre[class*="language-"] { white-space: pre !important; }
</style>


    </div>
    <div id="toc-aside" class="expanded col l3 hide-on-med-and-down">
        <div class="toc-widget" style="background-color: white;">
            <div class="toc-title"><i class="far fa-list-alt"></i>&nbsp;&nbsp;目录</div>
            <div id="toc-content"></div>
        </div>
    </div>
</div>

<!-- TOC 悬浮按钮. -->

<div id="floating-toc-btn" class="hide-on-med-and-down">
    <a class="btn-floating btn-large bg-color">
        <i class="fas fa-list-ul"></i>
    </a>
</div>


<script src="/libs/tocbot/tocbot.min.js"></script>
<script>
    $(function () {
        tocbot.init({
            tocSelector: '#toc-content',
            contentSelector: '#articleContent',
            headingsOffset: -($(window).height() * 0.4 - 45),
            collapseDepth: Number('4'),
            headingSelector: 'h2, h3, h4, h5'
        });

        // modify the toc link href to support Chinese.
        let i = 0;
        let tocHeading = 'toc-heading-';
        $('#toc-content a').each(function () {
            $(this).attr('href', '#' + tocHeading + (++i));
        });

        // modify the heading title id to support Chinese.
        i = 0;
        $('#articleContent').children('h2, h3, h4, h5').each(function () {
            $(this).attr('id', tocHeading + (++i));
        });

        // Set scroll toc fixed.
        let tocHeight = parseInt($(window).height() * 0.4 - 64);
        let $tocWidget = $('.toc-widget');
        $(window).scroll(function () {
            let scroll = $(window).scrollTop();
            /* add post toc fixed. */
            if (scroll > tocHeight) {
                $tocWidget.addClass('toc-fixed');
            } else {
                $tocWidget.removeClass('toc-fixed');
            }
        });

        
        /* 修复文章卡片 div 的宽度. */
        let fixPostCardWidth = function (srcId, targetId) {
            let srcDiv = $('#' + srcId);
            if (srcDiv.length === 0) {
                return;
            }

            let w = srcDiv.width();
            if (w >= 450) {
                w = w + 21;
            } else if (w >= 350 && w < 450) {
                w = w + 18;
            } else if (w >= 300 && w < 350) {
                w = w + 16;
            } else {
                w = w + 14;
            }
            $('#' + targetId).width(w);
        };

        // 切换TOC目录展开收缩的相关操作.
        const expandedClass = 'expanded';
        let $tocAside = $('#toc-aside');
        let $mainContent = $('#main-content');
        $('#floating-toc-btn .btn-floating').click(function () {
            if ($tocAside.hasClass(expandedClass)) {
                $tocAside.removeClass(expandedClass).hide();
                $mainContent.removeClass('l9');
            } else {
                $tocAside.addClass(expandedClass).show();
                $mainContent.addClass('l9');
            }
            fixPostCardWidth('artDetail', 'prenext-posts');
        });
        
    });
</script>

    

</main>




    <footer class="page-footer bg-color">
    
        <link rel="stylesheet" href="/libs/aplayer/APlayer.min.css">
<style>
    .aplayer .aplayer-lrc p {
        
        display: none;
        
        font-size: 12px;
        font-weight: 700;
        line-height: 16px !important;
    }

    .aplayer .aplayer-lrc p.aplayer-lrc-current {
        
        display: none;
        
        font-size: 15px;
        color: #42b983;
    }

    
    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body {
        left: -66px !important;
    }

    .aplayer.aplayer-fixed.aplayer-narrow .aplayer-body:hover {
        left: 0px !important;
    }

    
</style>
<div class="">
    
    <div class="row">
        <meting-js class="col l8 offset-l2 m10 offset-m1 s12"
                   server="netease"
                   type="playlist"
                   id="764454432"
                   fixed='true'
                   autoplay='false'
                   theme='#42b983'
                   loop='all'
                   order='random'
                   preload='none'
                   volume='0.7'
                   list-folded='true'
        >
        </meting-js>
    </div>
</div>

<script src="/libs/aplayer/APlayer.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/meting@2/dist/Meting.min.js"></script>

    
    <div class="container row center-align" style="margin-bottom: 15px !important;">
        <div class="col s12 m8 l8 copy-right">
            Copyright&nbsp;&copy;
            <span id="year">2017</span>
            <a href="/about" target="_blank">Escape</a>
            |&nbsp;Powered by&nbsp;<a href="https://hexo.io/" target="_blank">Hexo</a>
            |&nbsp;Theme&nbsp;<a href="https://github.com/blinkfox/hexo-theme-matery" target="_blank">Matery</a>
            <br>
            
            &nbsp;<i class="fas fa-chart-area"></i>&nbsp;站点总字数:&nbsp;<span
                class="white-color">911.7k</span>&nbsp;字
            
            
            
            
            
            
            <span id="busuanzi_container_site_pv">
                |&nbsp;<i class="far fa-eye"></i>&nbsp;总访问量:&nbsp;<span id="busuanzi_value_site_pv"
                    class="white-color"></span>&nbsp;次
            </span>
            
            
            <span id="busuanzi_container_site_uv">
                |&nbsp;<i class="fas fa-users"></i>&nbsp;总访问人数:&nbsp;<span id="busuanzi_value_site_uv"
                    class="white-color"></span>&nbsp;人
            </span>
            
            <br>
            
            <span id="sitetime">载入运行时间...</span>
            <script>
                function siteTime() {
                    var seconds = 1000;
                    var minutes = seconds * 60;
                    var hours = minutes * 60;
                    var days = hours * 24;
                    var years = days * 365;
                    var today = new Date();
                    var startYear = "2017";
                    var startMonth = "2";
                    var startDate = "14";
                    var startHour = "0";
                    var startMinute = "0";
                    var startSecond = "0";
                    var todayYear = today.getFullYear();
                    var todayMonth = today.getMonth() + 1;
                    var todayDate = today.getDate();
                    var todayHour = today.getHours();
                    var todayMinute = today.getMinutes();
                    var todaySecond = today.getSeconds();
                    var t1 = Date.UTC(startYear, startMonth, startDate, startHour, startMinute, startSecond);
                    var t2 = Date.UTC(todayYear, todayMonth, todayDate, todayHour, todayMinute, todaySecond);
                    var diff = t2 - t1;
                    var diffYears = Math.floor(diff / years);
                    var diffDays = Math.floor((diff / days) - diffYears * 365);
                    var diffHours = Math.floor((diff - (diffYears * 365 + diffDays) * days) / hours);
                    var diffMinutes = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours) /
                        minutes);
                    var diffSeconds = Math.floor((diff - (diffYears * 365 + diffDays) * days - diffHours * hours -
                        diffMinutes * minutes) / seconds);
                    if (startYear == todayYear) {
                        document.getElementById("year").innerHTML = todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffDays + " 天 " + diffHours +
                            " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    } else {
                        document.getElementById("year").innerHTML = startYear + " - " + todayYear;
                        document.getElementById("sitetime").innerHTML = "本站已安全运行 " + diffYears + " 年 " + diffDays +
                            " 天 " + diffHours + " 小时 " + diffMinutes + " 分钟 " + diffSeconds + " 秒";
                    }
                }
                setInterval(siteTime, 1000);
            </script>
            
            <br>
            
        </div>
        <div class="col s12 m4 l4 social-link social-statis">
    <a href="https://github.com/EscapeLife" class="tooltipped" target="_blank" data-tooltip="访问我的GitHub" data-position="top" data-delay="50">
        <i class="fab fa-github"></i>
    </a>



    <a href="mailto:wenpanhappy@126.com" class="tooltipped" target="_blank" data-tooltip="邮件联系我" data-position="top" data-delay="50">
        <i class="fas fa-envelope-open"></i>
    </a>













    <a href="/atom.xml" class="tooltipped" target="_blank" data-tooltip="RSS 订阅" data-position="top" data-delay="50">
        <i class="fas fa-rss"></i>
    </a>

</div>
    </div>
</footer>

<div class="progress-bar"></div>


    <!-- 搜索遮罩框 -->
<div id="searchModal" class="modal">
    <div class="modal-content">
        <div class="search-header">
            <span class="title"><i class="fas fa-search"></i>&nbsp;&nbsp;搜索</span>
            <input type="search" id="searchInput" name="s" placeholder="请输入搜索的关键字"
                   class="search-input">
        </div>
        <div id="searchResult"></div>
    </div>
</div>

<script src="/js/search.js"></script>
<script type="text/javascript">
$(function () {
    searchFunc('/search.xml', 'searchInput', 'searchResult');
});
</script>

    <!-- 回到顶部按钮 -->
<div id="backTop" class="top-scroll">
    <a class="btn-floating btn-large waves-effect waves-light" href="#!">
        <i class="fas fa-arrow-up"></i>
    </a>
</div>


    <script src="/libs/materialize/materialize.min.js"></script>
    <script src="/libs/masonry/masonry.pkgd.min.js"></script>
    <script src="/libs/aos/aos.js"></script>
    <script src="/libs/scrollprogress/scrollProgress.min.js"></script>
    <script src="/libs/lightGallery/js/lightgallery-all.min.js"></script>
    <script src="/js/matery.js"></script>

    <!-- Baidu Analytics -->

    <!-- Baidu Push -->

<script>
    (function () {
        var bp = document.createElement('script');
        var curProtocol = window.location.protocol.split(':')[0];
        if (curProtocol === 'https') {
            bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
        } else {
            bp.src = 'http://push.zhanzhang.baidu.com/push.js';
        }
        var s = document.getElementsByTagName("script")[0];
        s.parentNode.insertBefore(bp, s);
    })();
</script>

    
    <script src="/libs/others/clicklove.js" async="async"></script>
    
    
    <script async src="/libs/others/busuanzi.pure.mini.js"></script>
    

    

    

    

    

    
    <script type="text/javascript" src="/libs/background/ribbon-dynamic.js" async="async"></script>
    

    
    <script src="/libs/instantpage/instantpage.js" type="module"></script>
    

</body>

</html>
